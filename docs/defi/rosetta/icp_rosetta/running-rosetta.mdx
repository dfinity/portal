---
keywords: [intermediate, rosetta, tutorial, docker, source, validation cloud, deployment]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Running ICP Rosetta

<MarkdownChipRow labels={["Intermediate", "Rosetta"]} />

There are several ways to run ICP Rosetta depending on your use case and requirements. This guide covers all available deployment methods.

## Docker (Recommended)

The easiest way to run ICP Rosetta is using the official Docker image. This method is recommended for most users.

### Prerequisites

- [x] [Docker](https://docs.docker.com/get-docker/) installed and running.
- [x] [Docker daemon](https://docs.docker.com/config/daemon/) started.

```bash
docker pull dfinity/rosetta-api
```

### Quick Start - Test Environment

Start here for learning and development. The test environment uses `TESTICP` tokens that have no real value.

```bash
docker run \
    --publish 8081:8081 \
    --rm \
    dfinity/rosetta-api \
    --environment test
```

:::info
To get `TESTICP` tokens for testing, you can use the faucet [here](https://nqoci-rqaaa-aaaap-qp53q-cai.icp0.io/). This provides test tokens without needing to use real ICP.
:::

### Basic Production Deployment

For quick production setup using the official ICP ledger on mainnet. **Note**: Data will be lost when the container restarts.

```bash
docker run \
    --publish 8081:8081 \
    --rm \
    dfinity/rosetta-api \
    --environment production
```

### Production with Data Persistence

For production environments where you need to persist blockchain data across container restarts:

```bash
# Create a volume for data persistence
docker volume create rosetta

# Run in production mode with data persistence
docker run \
    --volume rosetta:/data \
    --publish 8081:8081 \
    --detach \
    dfinity/rosetta-api:v2.1.7 \
    --environment production
```

This setup ensures that your node doesn't need to re-sync from scratch if the container is restarted.

:::info
It's recommended to use specific versions in production for consistency and predictable deployments.
Check available versions on [DockerHub](https://hub.docker.com/r/dfinity/rosetta-api/tags).
:::


### Custom Configurations

To connect to a custom test ledger canister instance (useful for development with specific test setups):

```bash
docker run \
    --publish 8081:8081 \
    --rm \
    dfinity/rosetta-api \
    --environment test \
    --canister <ledger-canister-id>
```

## Building from source

You can build and run ICP Rosetta directly from the Internet Computer source code.

### Prerequisites

- [x] [Bazel](https://bazel.build/) build system.
- [x] Internet Computer repository cloned locally: `git clone https://github.com/dfinity/ic.git`.

### Build and run

```bash
# Clone the IC repository (if not already done)
git clone https://github.com/dfinity/ic.git
cd ic

# Build and run ICP Rosetta
bazel run //rs/rosetta-api/icp:ic-rosetta-api -- \
    --port 8081 \
    --environment production \
    --store-location /tmp
```

:::info
The `--store-location` parameter is important when running from source as it specifies where the database files will be stored. Without this parameter, the default location may not be writable or accessible.
:::

This method gives you the latest development version and allows for custom modifications.

## Validation Cloud

For those who prefer not to run Rosetta locally, Validation Cloud offers managed ICP Rosetta endpoints that you can use for learning, development, and production.

### Features

- Managed infrastructure (no local setup required).
- Global distribution with multi-region support.
- 99.99% uptime SLA.
- 24/7 customer support.
- SOC 2 Type 2 compliance.

### Getting started

1. Visit [Validation Cloud ICP page](https://www.validationcloud.io/icp).
2. Sign up for an account.
3. Choose between Free tier (50M Compute Units) or Scale plan (unlimited).
4. Get your API endpoint and start building.

### Supported APIs

- ICP Rosetta nodes for ledger communication.
- ICRC API for token interactions.
- Access to NNS governance canister.

This option is useful for:
- Quick prototyping and learning.
- Development without local infrastructure setup.
- Production applications that prefer managed services.

## Verification and testing

Regardless of the deployment method, you can verify your Rosetta node is working:

### Check node status

```bash
curl -H "Content-Type: application/json" \
  -d '{"network_identifier": {"blockchain": "Internet Computer", "network": "00000000000000020101"}}' \
  -X POST http://localhost:8081/network/status
```

### Check version

```bash
curl -H "Content-Type: application/json" \
  -d '{"network_identifier": {"blockchain": "Internet Computer", "network": "00000000000000020101"}}' \
  -X POST http://localhost:8081/network/options | jq '.version.node_version'
```

### Wait for sync

Look for the message: `You are all caught up to block XX` in the logs to confirm the node is synchronized.

## Requirements and limitations

- **Transaction timing**: Unsigned transactions must be created less than 24 hours before submission due to the [deduplication mechanism](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/README.md#transaction_deduplication).
- **Signature schemes**: Examples typically use Ed25519 and SECP256k1.
- **Port**: Default listening port is 8081.
- **Data persistence**: Mount `/data` directory as a volume for Docker deployments.
