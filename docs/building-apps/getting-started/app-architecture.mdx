---
keywords: [beginner, getting started, app architecture, application architecture, how it works, how apps work, how canisters work, how canisters communicate, canister smart contracts]
---

import TabItem from "@theme/TabItem";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";
import { OsType, useOs } from "/src/hooks/useOs";
import useBaseUrl from "@docusaurus/useBaseUrl";

# Application architecture

<MarkdownChipRow labels={["Beginner", "Getting started", "Tutorial"]} />

Applications deployed on ICP are comprised of one or more specialized smart contracts known as **canisters**. A canister contains application code and its corresponding state. The application's logic, referred to as the **backend** can be written in a variety of different languages including Motoko, Rust, and Typescript. The user interface of the application, referred to as the frontend, can include assets like HTML, CSS, and Javascript.

The most common architecture for an application on ICP includes one canister for the frontend assets and one or more canisters containing the backend application logic.

<div class="text--center">
  <img
    src={useBaseUrl("/img/docs/app-arch.svg")}
    alt="Application architecture"
    width="800"
  />
</div>

## What you'll learn

- **[Project structure](#project-structure-and-files)**: Explore the necessary files to create an application.

- **[Code components and methods](#code-structure)**: View the code of the "Hello, world!" app you created in the [quick start](quickstart.mdx) tutorial.

- **[Interact with the application's backend](#call-the-backend-canister)**: Learn how the canister's code responds to calls.

- **[Add a simple frontend](#adding-a-frontend)**: Create a user interface using HTML and CSS.

- **Backend and frontend canister communication**: Learn about agents and how they are used for canister communication.

- **User interaction**: View how user interaction with the frontend is handled by the application.

<AdornedTabs>
<TabItem label="Prerequisites">

<input type="checkbox"/> Complete the <a href="/docs/building-apps/getting-started/quickstart">quickstart</a> tutorial.

</TabItem>
</AdornedTabs>

## Project structure and files

At minimum, an application requires two files:

- `dfx.json`: The project's configuration file.

- Backend canister source code: Code defining the application's logic. This code should include methods that can be called by a user or other canister and return a response. In the [quick start example](quickstart.mdx), this code is written in Motoko and stored in a file called `main.mo`.

You should have these files in a local directory called `hello` if you followed the [quick start tutorial](quickstart.mdx). This project is also available on the [ICP Ninja web IDE](https://icp.ninja/projects/01931adc-4a79-766c-84c3-9c9688d82ae4).

### `dfx.json`

Your project's directory contains a file called `dfx.json`. This file is used to configure your project's settings. It includes the project's canister definitions which indicate the canister names, types, and source code files.

```json title=dfx.json
{
  "canisters": {
    "hello_backend": { // Backend canister name
      "main": "src/hello_backend/main.mo", // Backend canister source code
      "type": "motoko" // Canister language
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
```

Learn more about [dfx.json].

### Backend canister source code

The `src/hello_backend/main.mo` file contains the source code for a basic "Hello, world!" app written in Motoko.

```motoko title="src/hello_backend/main.mo" no-repl
actor {
public query func greet(name : Text) : async Text {
    return "Hello, " # name # "!";
  };
};
```

A canister's code is compiled into [WebAssembly (Wasm)] before it is deployed to ICP. Each canister development kit (CDK) comes with build scripts that compile canister code into Wasm programs that are compatible with ICP. These build scripts are executed by `dfx` as part of the `dfx deploy` command or through the explicit compilation command `dfx build`.

## Code structure

Let's take a closer look at the code structure of the `src/hello_backend/main.mo` file.

First, the code defines an **actor**. An actor is an object used to encapsulate the state of the code.

```motoko title="src/hello_backend/main.mo" no-repl
actor {
```

Next a function called `greet` is defined using the following syntax components:

```motoko title="src/hello_backend/main.mo" no-repl
public query func greet(name : Text) : async Text {
```

- `public`: Defines the function as callable by users or other canisters. Functions are also referred to as **methods** in the context of canisters.

- `query`: Defines the type of message that will be used to call the method.

- `func greet`: Indicates the method's name.

- `(name : Text) : async Text`: Indicates that this method will accept an input of type `Text` from a call. It will be stored in the variable `name`. Then, the method will return a `Text` value to the caller in an `async` manner.

Lastly, the method's return content is defined:

```motoko title="src/hello_backend/main.mo" no-repl
    return "Hello, " # name # "!";
  };
};
```

This return output includes the text `"Hello, "`, followed by the value stored in the `name` variable that was passed to the method by the caller.

## Call the backend canister

To interact with the canister's `greet` method, you will make a call to the canister:

```
dfx canister call hello_backend --playground greet ICP
```

The parts of this command are:

- `dfx canister call`: The `dfx` command used to call canisters.

- `hello_backend`: The canister's name which you are calling.

- `--playground`: The network the canister is deployed and running on.

- `greet ICP`: The name of the method you want to call followed by the input you want to pass to it.

The canister will return the following output:

```
("Hello, ICP!")
```

:::caution
If you get an error that the canister does not exist, you may need to deploy it again with the command:

```
dfx deploy --playground
```
:::

A canister's methods can be called by both users and other canisters.

### What this command did

The `dfx canister call` command sent a message to the `hello_backend` canister that is deployed on the `--playground` network. Then the message was sent to the `greet` method, which was given the input of "ICP". This input is of type `Text` and thus accepted by the method as valid input.

Since the method is defined as a `query` method, the canister simply returns data to the caller; it does not alter the canister's code or state.

You can also make this call from the canister's [Candid interface].

## Add a frontend

The frontend of the application is used to facilitate user interaction with the functionality defined in the backend code. It is made up of assets, most commonly HTML, CSS, JavaScript, images, or video files. Popular frameworks like React, Vite, or Svelte are also supported.

On ICP, an application's frontend is created through the following steps:

1. A developer creates files that are intended to be part of the application's frontend.

2. The project's `dfx.json` file is edited to include a canister definition for the frontend canister. This definition must specify the frontend canister type as `"type": "asset"`.

3. When project is deployed, `dfx` uses an implementation of the [asset canister interface](https://github.com/dfinity/sdk/blob/master/docs/design/asset-canister-interface.md) to compile the frontend canister.

In this example, the user will communicate with the backend canister's `greet` method through a text input box and a button. The text input box will be used to capture the input that will be passed to the backend and the button will be used to send the call.

At minimum you will need:

- **An entrypoint file**: This will be served when the frontend is initially loaded, i.e., `index.html`.

- **Frontend framework configuration file:** In this example, the `vite.config.js` file will be used to configure [Vite].

- `package.json`: Used to download required dependencies.

### `index.html`

Create a new file called `src/hello_frontend/index.html`. This will create the user interface for the application.

```html title="src/hello_frontend/index.html"
<!doctype html>
<html>
  <head>
    <title>Hello, world!</title>
    <style>
      body {
        padding: 10px 60px;
        font-family: sans-serif;
        font-size: 1.5rem;
      }
      #greeting {
        margin: 10px auto;
        padding: 10px 60px;
        border: 1px solid #222;
      }
      #greeting:empty {
        display: none;
      }
    </style>
    <script type="module">

      // Import the actor defined in the backend
      import { backend } from 'declarations/backend';

      // Add an event listener to the form
      // This will listen for user interaction with the form
      document.querySelector('form').addEventListener('submit', async (e) => {
        e.preventDefault();

        // Save the user input from the form in the variable 'name'
        const name = document.getElementById('name').value.toString();

        // Call the backend canister's method 'greet'
        // and wait for the backend to reply
        const greeting = await backend.greet(name);

        // Display the greeting returned by the backend
        document.getElementById('greeting').innerText = greeting;
      });
    </script>
  </head>
  <body>
    <main>
      <form>
      // Create a text input box to capture the user's input
        <label for="name">Enter your name: &nbsp;</label>
        <input id="name" alt="Name" type="text" />
        // Create a button that will trigger the call to the backend
        <button type="submit">Click Me!</button>
      </form>
      // Define where the backend's response will be displayed
      <section id="greeting"></section>
    </main>
  </body>
</html>
```

When the application is deployed, `dfx` will generate files that include JavaScript boilerplate code for the frontend. Under the hood, this boilerplate code uses an API client called the [ICP JavaScript agent] to encode [Candid] values and facilitate HTTP requests from the frontend to the backend.

An agent makes calls to the backend canister's methods similar to how you used `dfx canister call` to call the backend from the command line. [Learn more about ICP agents].

### `vite.config.json`

Create a new file called `src/hello_frontend/vite.config.js`. This contains the configuration information for the frontend canister to use the framework [Vite]:

```js title="src/hello_frontend/vite.config.js"
import { defineConfig } from 'vite';
import { fileURLToPath, URL } from 'url';
import environment from 'vite-plugin-environment';

export default defineConfig({
  base: './',
  plugins: [environment('all', { prefix: 'CANISTER_' }), environment('all', { prefix: 'DFX_' })],
  envDir: '../',
  define: {
    'process.env': process.env
  },
  optimizeDeps: {
    esbuildOptions: {
      define: {
        global: 'globalThis'
      }
    }
  },
  resolve: {
    alias: [
      {
        find: 'declarations',
        replacement: fileURLToPath(new URL('../src/declarations', import.meta.url))
      }
    ]
  },
  server: {
    proxy: {
      '/api': {
        target: 'http://127.0.0.1:4943',
        changeOrigin: true
      }
    },
    host: '127.0.0.1'
  }
});
```

### `package.json`

Create a new file called `src/hello_frontend/package.json`. This contains the node packages the project must download, including the ICP agent and Vite:

```json title="src/hello_frontend/package.json"
{
  "name": "frontend",
  "private": true,
  "type": "module",
  "scripts": {
    "prebuild": "npm i --include=dev && dfx generate backend",
    "build": "vite build",
    "dev": "vite"
  },
  "dependencies": {
    "@dfinity/agent": "2.2.0"
  },
  "devDependencies": {
    "vite": "5.4.11",
    "vite-plugin-environment": "1.1.3"
  }
}
```

### Edit `dfx.json`

Lastly, edit the `dfx.json` file to include the frontend canister:

```json title="dfx.json"
{
  "canisters": {
    "hello_backend": {
      "main": "hello_backend/main.mo",
      "type": "motoko"
    },
    // highlight-start
    "hello_frontend": {
      "dependencies": ["backend"],
      "frontend": {
        "entrypoint": "hello_frontend/index.html"
      },
      "source": ["hello_frontend"],
      "type": "assets"
    }
  },
  // highlight-end
  "output_env_file": ".env",
  "defaults": {
    "build": {
      "packtool": ""
    }
  }
}
```

### Updated project structure

At this point, your project's structure should be:

```
hello
├── backend
│   └── app.mo
├── dfx.json
└── frontend
    ├── index.html
    ├── package.json
    └── vite.config.js
```


## User interaction

