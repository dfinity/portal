---

keywords: [advanced, concept, vetkd, vetkeys, encryption, threshold decryption, encrypted threshold key derivation, encrypted maps, dkms, distributed key management service]

---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# `EncryptedMaps`

<MarkdownChipRow labels={["Advanced", "EncryptedMaps"]} />

An additional component of the [decentralized key management service (DKMS)](docs/building-apps/network-features/vetkeys/dkms/introduction) is `EncryptedMaps`, which builds on top of another DKMS module, [`KeyManager`](./key_manager.mdx). `EncryptedMaps` provides a collection of access-controlled maps for storing user-encrypted data, where encryption is performed using vetKeys.


One of the key benefits of `EncryptedMaps` is that developers don't need significant knowledge in cryptography to add vetKey-based encryption to their dapps.

`EncryptedMaps` (similar to `KeyManager`) identifies maps based on two pieces of information:
1. Map owner's principal.
2. An arbitrary byte string, e.g., a human-readable string encoded as bytes. 

Each encrypted map is associated with a single vetKey and one access control scope. Regardless of how many key-value pairs it contains, only one `vetKey` is needed per map. All key-value pairs inherit the same access permissions as the map itself.

An encrypted map functions similarly to a standard map in most programming languages, with keys and values represented as byte strings. However, the values are encrypted. The key difference is that encrypted maps are not meant to be used directly by the canister. Any data encrypted or decrypted by the canister is considered public. Instead, users handle encryption and decryption to maintain privacy.

A key advantage of `EncryptedMaps` is that encryption is entirely opaque to developers using the frontend APIs. Developers specify where the data should go, namely, the map name and key, but not how it's encrypted or decrypted. The encryption is designed to be secure, efficient, and to minimize the number of `vetKeys` that need to be fetched from ICP.


## Core features

Beyond the inherited features of `KeyManager`, `EncryptedMaps` has also the following features:
- **Encrypted key-value storage**: Store and retrieve encrypted key-value pairs within named maps.
- **Cleartext APIs**: The frontend library for `EncryptedMaps` offers developers cleartext APIs.
- **Store data anywhere**: `EncryptedMaps` provides a possibility to implement encrypted data store outside canisters, e.g., locally, while using vetKeys.
- **Shared maps access information**: Query which maps a user has access to.
- **Manage user access**: Assign, modify, and revoke user rights on stored maps.  

## Application backend component

<AdornedTabs groupId="languages">
<TabItem value="rs" label="Rust" default>

Below is an example of how to instantiate the backend `KeyManager` component inside a canister.

```rust no-repl reference
https://github.com/dfinity/vetkd-devkit/blob/3b1de5d546dcc32daaf22b21baaa2b220bc857f3/backend/rs/canisters/ic_vetkeys_encrypted_maps_canister/src/lib.rs#L1-L26
```

</TabItem>
</AdornedTabs>

## Application frontend component

Your application's frontend can communicate with a `KeyManager`-enabled canister using the following TypeScript code:

<AdornedTabs groupId="languages">
<TabItem value="ts" label="Typescript" default>

Instantiate and use `KeyManager` in the frontend.

```ts
import { EncryptedMaps } from "ic_vetkeys/encrypted_maps";

// Initialize the EncryptedMaps Client
const encryptedMaps = new EncryptedMaps(encryptedMapsClientInstance);

// Retrieve shared maps
const sharedMaps = await encryptedMaps.getAccessibleSharedMapNames();

const mapOwner = Principal.fromText("aaaaa-aa");
const mapName = "passwords";
const mapKey = "email_account";

// Store an encrypted value
const value = new TextEncoder().encode("my_secure_password");
const result = await encryptedMaps.setValue(mapOwner, mapName, mapKey, value);

// Retrieve a stored value
const storedValue = await encryptedMaps.getValue(mapOwner, mapName, mapKey);

// Manage user access rights
const user = Principal.fromText("bbbbbb-bb");
const accessRights = { ReadWrite: null };
const result = await encryptedMaps.setUserRights(mapOwner, mapName, user, accessRights);
```

</TabItem>
</AdornedTabs>

## Examples

- **[Password manager](https://github.com/dfinity/vetkd-devkit/tree/3b1de5d546dcc32daaf22b21baaa2b220bc857f3/examples/password_manager)**: Use the default `EncryptedMaps` canister with a frontend that implements a simple password manager, where the passwords are encrypted using vetKeys.
- **[Password manager with metadata](https://github.com/dfinity/vetkd-devkit/tree/3b1de5d546dcc32daaf22b21baaa2b220bc857f3/examples/password_manager_with_metadata)**: Store additional metadata in the canister (both user-provided and canister-generated) and include this metadata alongside the encrypted data in atomic password addition or removal operations.

## Resources

- [Rust backend `EncryptedMaps` code documentation](https://todo).

- [Motoko backend `EncryptedMaps` code documentation](https://todo).

- [TypeScript frontend `EncryptedMaps` code documentation](https://5lfyp-mqaaa-aaaag-aleqa-cai.icp0.io/classes/ic_vetkeys_tools.EncryptedMaps.html).