---

keywords: [advanced, concept, vetkd, vetkeys, encryption, threshold decryption, encrypted threshold key derivation, dkms, distributed key management service]

---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# What is DKMS?

<MarkdownChipRow labels={["Advanced", "Key derivation", "Encryption"]} />

vetKeys can be used to facilitate a distributed key management service (DKMS). vetKeys obtained from ICP are only known to the client that requested them, therefore they can be used for different purposes such as encryption, signing, and further key derivation.
These keys can be shared with other users by adding corresponding user permissions in the canister.
The DKMS is a set of tools that allows for exactly that and exposes a high-level API that does not require the user to have extensive knowledge in cryptography.

The DKMS has two primary components:
- **[`KeyManager`](./key-manager.mdx)** Access control and vetKey derivation.
- **[`EncryptedMaps`](./encrypted-maps.mdx)**: Builds on top of the `KeyManager` for efficient data encryption and storage in a key-value store.

## Benefits of DKMS

DKMS is a **ready-to-use solution**. It offers:

- **Simple, cleartext frontend APIs** for key derivation and data encryption. No need to define or manage your own cryptographic primitives.

- **Efficiency** in design. Minimizes the number of `vetKey` derivation calls, saving on compute and time.

- **Deterministic key generation**. Built on the **strong randomness** of `vetKeys`.

- Built-in **access control** for keys and encrypted data. No peer-to-peer interaction required. Parties receiving access permissions donâ€™t need to be online during the process. 

- Enhanced security when fetching keys on demand. Avoids persisting sensitive keys locally, reducing the risk of key compromise.

## How it works

The canister determines access control. It controls what keys a user owns and what keys are shared with other users, including specific access rights (e.g., whether an added user can further share the key). Furthermore, access control in DKMS is flexible as well, such that it can be extended to further restrict access to keys based on time.

Every key identity is defined by the user's principal and an arbitrary byte string. This separates the domains from which users can derive keys, but still allows them to derive an arbitrary number of keys. Since every key identity contains the key's owner, the key owner is implicit. Only the information about the sharing of the key must always be stored in the canister.

Both `KeyManager` and `EncryptedMaps` provide libraries for the backend as well as the frontend. In the backend, the library provides a component that can be added to the canister. In the frontend, the library provides a way to communicate with a `KeyManager` or `EncryptedMaps`-enabled canister. The developer's role in the implementation is to define how to use their canister's APIs to let the frontend library communicate with the backend component.

A developer using DKMS can add new functionalities to or around DKMS in a few ways:

- Code extensions that don't require functional modifications of DKMS can be implemented very simply. For example, if the developer wants to add a counter that would count how many times a particular user called a particular API.

- The existing methods of DKMS can be used in different ways. For example, one may want to add a user to multiple keys in one go. To achieve that, the frontend and canister API would need to define the batch addition of access permissions, but there would need to be no changes to the backend component.

- The internal fields of the backend are public, and thus, it is possible to add new functions to DKMS. For example, `KeyManager` provides a method to remove user's access permissions for a key. The developer can easily implement a function that removes user access from all keys in one method.
