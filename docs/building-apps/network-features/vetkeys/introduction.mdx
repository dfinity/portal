---

keywords: [advanced, concept, vetkd, vetkeys, encryption, threshold decryption, encrypted threshold key derivation]

---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# What are vetKeys?

<MarkdownChipRow labels={["Advanced", "Encryption"]} />

vetKeys on the Internet Computer (ICP) allow developers to more easily perform encryption, threshold decryption, and signing when building dapps on ICP. It is powered by a protocol called vetKD (Verifiably Encrypted Threshold Key Derivation) that allows deriving decryption keys on demand. vetKeys enable a public blockchain to hold secret data.

The goal of vetKeys is to ease the burden of using security and privacy tools on ICP. Encrypting information locally on a device and storing it on a blockchain is easy, as the secret key material always remaining on the local device and not being exposed. Without a solution like vetKeys, difficulties arise when a user wants to retrieve the encrypted information from a different device or share it with a different user, as there is no straightforward way to pass secret key material across public channels in a privacy-friendly way.

vetKeys leverages the fact that [BLS signatures](https://learn.internetcomputer.org/hc/en-us/articles/34209540682644-Subnet-Keys-and-Subnet-Signatures), the native signature scheme on ICP, are unique and therefore ideally suited to be used as cryptographic decryption keys. As BLS signatures are computed in a distributed way on ICP, there is no central authority deriving keys for users. Furthermore, following standard practices in [Identity-Based Encryption (IBE) schemes](/docs/references/vetkeys-overview), the derived key can be transported to the user in an encrypted manner. As such, nodes and the network never have access to a userâ€™s keys.

## vetKeys use cases and applications

The availability of vetKeys allows for a series of applications, including but not limited to those covered in the following sections.

### [Distributed Key Management Service (DKMS)](./dkms.mdx)

DKMS is a higher-level library based on vetKeys. Its main goal of DKMS is to provide APIs that are simple to use, especially for developers without extensive knowledge in cryptography. DKMS enables multiple users to securely generate, manage, and share cryptographic keys. Those keys can be used for encryption, decryption, or signing of data.

DKMS provides two types of APIs:
- **KeyManager** - Key derivation and sharing.
- **EncryptedMaps** - **Efficient** encryption and decryption of data using **cleartext APIs** and storing the encrypted data in a **key-value store** in a canister (ICP smart contract).

The main use case of DKMS is to enable a blockchain to host threshold-encrypted data in a way that scales to millions of users and billions of secrets, using just a single threshold-shared secret key. BLS signatures are unique, making them immediately useful as symmetric keys.

Think, for example, of a secure file storage dapp: a user could use DKMS to encrypt their files before storing them in the dapp. The dapp enforces that only the authenticated user is allowed to decrypt the files. The nodes in the blockchain assist a user in recovering their keys but never see those keys or the decrypted content of the files.

A further example with more sophisticated access policies is a secure messaging dapp, where the conversation between two users is encrypted using the pair of identities, to which only those users are given access by the dapp. A secure decentralized social network could let users encrypt posts using a key that is related to the post, e.g., a unique identifier for the post. The SocialFi dapp then ensures that only the author and the users that the post is shared with get access to that key.

### [Blockchain-issued BLS signatures](./advanced/bls-signatures.mdx)

vetKeys can be used as signatures issued by the blockchain. This is especially useful for blockchains that don't have a built-in certification feature enabling dapps to sign statements.

It can also be used to efficiently bridge blockchains, e.g., to swap assets in a DeFi application. A dapp on one blockchain can verify signed statements issued by a second blockchain without having to implement a complete light client of that second chain.

### [Identity-Based Encryption (IBE)](./advanced/identity-based-encryption.mdx)

IBE facilitates encryption to an identity, where the dapp controls which user has which identity, e.g., each user can get a vetKey - used as an IBE decryption key - for its ICP principal.

Compared to DKMS, IBE is different. In DKMS, one or more users hold **the same** symmetric key, and only the users that know the key can encrypt. IBE, on the other hand, is an asymmetric encryption scheme, meaning that anyone can encrypt messages to any identity, also to other canisters, but only the users knowing the key can decrypt them. IBE is somewhat more advanced than DKMS in the sense that we derive an asymmetric encryption scheme using vetKeys and are not just using vetKeys for symmetric key derivation.

### [Time-lock encryption](./advanced/timelock-encryption.mdx)

Time-lock encryption enables a sender to encrypt a message for the future, ensuring that it will get decrypted at a given time, but no earlier than that time. Time-lock encryption can be achieved via IBE by letting the dapp release the IBE decryption keys corresponding to the current time at regular intervals (eventually decrypting the ciphertexts in the canister) and letting the sender IBE-encrypt its message using the desired decryption time as identity. Also more sophisticated time-lock conditions are possible (see below).

#### "Dead man's switch"

Journalists or whistleblowers could ensure that compromising information in their possession is automatically published if they were to become incapacitated. They can store the information in a dapp, encrypted using IBE that the dapp automatically and publicly recovers when a certain amount of time passes after it last received an authenticated ping from its owner.

#### Secret-bid auctions and MEV protection

A vetKey-equipped blockchain can also cover use cases where many ciphertexts need to be decrypted at the same time.

In a secret-bid auction dapp, users can submit bids that are IBE-encrypted under an identifier so that at the end of the auction, the dapp can decrypt all bids with a single vetKey evaluation. A similar technique can be used to prevent front-running, also known as miner-extracted value (MEV), on a decentralized exchange (DEX). Users submit their IBE-encrypted transactions under a predictable batch identifier. The DEX orders the transactions in encrypted form and, when all transactions for a particular batch have been ordered, triggers the recovery of the decryption key for that batch and executes the decrypted transactions in the fixed order. Note that all of the symmetric-encryption use cases listed above can be modified to encrypt using an IBE instead of a symmetric-key encryption, thereby eliminating the need to perform a vetKey derivation for encryption. Decryption, of course, still requires a vetKey evaluation.

#### Advanced time-locks

Anyone can IBE-encrypt their message using some more complex condition as identity, while a the dapp lets anyone who can satisfy the condition (or when the condition is satisfied on its own) to obtain the respective vetKey. This enables quite interesting use cases, as it enables one to encrypt to any verifiable future event, e.g., the price of a stock going above or below a certain level, information escrow, or break-the-glass policies.

### [Externally verifiable randomness](./advanced/verifiable-randomness.mdx)

Because of their uniqueness, BLS signatures can also act as a Verifiable Random Function (VRF). Trusted, verifiable randomness is important for applications such as trustless online lotteries and casinos, fair decentralized games (GameFi), and selecting random features for non-fungible tokens (NFTs).

Note that if your dapp does not need external verification (this is normally the case for dapps with public code running solely on ICP and no other blockchains), it is more efficient and much cheaper to use secure randomness on ICP that is not externally verifiable, see TODO:LINK.

## vetKeys API

The management canister provides the following low-level API for vetKeys.

```candid
  vetkd_public_key : (record {
    canister_id : opt canister_id;
    context : blob;
    key_id : record { curve : vetkd_curve; name : text };
  }) -> (record { public_key : blob; });
  vetkd_derive_key : (record {
    input : blob;
    context : blob;
    transport_public_key : blob;
    key_id : record { curve : vetkd_curve; name : text };
  }) -> (record { encrypted_key : blob; });
```

The full specification for vetKeys can be found in the [vetKD specification PR](https://github.com/dfinity/portal/pull/3763) (soon to be merge to the [ICP specification](https://internetcomputer.org/docs/references/ic-interface-spec#ic-vetkd_derive_key)).

## Resources

- [Forum discussion](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560).

- [The first Community Conversation](https://youtu.be/baM6jHnmMq8).

- [vetKeys reference](/docs/references/vetkeys-overview).

- [Research paper](https://eprint.iacr.org/2023/616.pdf).

