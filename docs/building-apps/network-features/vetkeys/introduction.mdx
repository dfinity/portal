---

keywords: [advanced, concept, vetkd, vetkeys, encryption, threshold decryption, encrypted threshold key derivation]

---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# What are vetKeys?

<MarkdownChipRow labels={["Advanced", "Encryption"]} />

`vetKeys` on the Internet Computer (ICP) make it easier for developers to implement encryption, threshold decryption, and signing in their dapps. They are powered by the `vetKD` protocol (Verifiably Encrypted Threshold Key Derivation), which enables secure, on-demand key derivation. With `vetKeys`, a public blockchain like ICP can hold and work with secret data securely.

The goal of `vetKeys` is to simplify the use of security and privacy tools on ICP. Encrypting data locally and storing it onchain is straightforward, since the secret key stays on the device. However, challenges arise when a user wants to access that data from another device or share it with someone else, as there’s no easy, privacy-preserving way to transmit secret key material across public channels. `vetKeys` solve this by enabling secure, on-demand key access without exposing secrets.

`vetKeys` leverages the fact that [BLS signatures](https://learn.internetcomputer.org/hc/en-us/articles/34209540682644-Subnet-Keys-and-Subnet-Signatures), the native signature scheme on ICP, are unique, making them well-suited for use as cryptographic decryption keys. As BLS signatures are computed in a distributed manner across ICP subnets, there is no central authority generating keys for users.

Following standard practices in [identity-based encryption (IBE) schemes](/docs/references/vetkeys-overview), the derived keys are securely transported to users in encrypted form. This ensures that neither individual nodes nor the network ever have access to a user’s private keys.

## vetKeys use cases and applications

The availability of vetKeys allows for a series of applications, including but not limited to those covered in the following sections.

### [Distributed key management service (DKMS)](docs/building-apps/network-features/vetkeys/dkms/introduction)

`DKMS` is a higher-level library built on top of `vetKeys`, designed to offer simple, developer-friendly APIs especially for those without cryptographic expertise. It allows users to securely generate, manage, and share cryptographic keys using `vetKeys` and ICP. These keys can then be used for encryption, decryption, or data signing.

DKMS has two primary components:
- **[`KeyManager`](dkms/key-manager.mdx)**: Access control and vetKey derivation.
- **[`EncryptedMaps`](dkms/encrypted-maps.mdx)**: Built on top of the `KeyManager` for efficient data encryption and storage in a key-value store.

One of the primary use cases of `DKMS` is to enable a blockchain to securely encrypt and host data at scale to support millions of users and billions of secrets. Because BLS signatures are unique, they can be directly used as symmetric keys. For example:

- **Secure file storage**: In a secure file storage dapp, users can encrypt their files using `DKMS` before uploading them. The dapp ensures that only authorized users can decrypt the files. While blockchain nodes assist in key recovery, they never see the private keys or decrypted file contents.

- **Secure messaging**: A secure messaging dapp can encrypt conversations using the identities of the two participants. The dapp manages access so only those users can retrieve the decryption keys.

- **Decentralized social networking (SocialFi)**: In a decentralized social network, posts can be encrypted with a key tied to a unique post identifier. The SocialFi dapp ensures that only the author and selected recipients have access to the corresponding decryption key.

### [Blockchain-issued BLS signatures](/docs/building-apps/network-features/vetkeys/advanced/bls-signatures)

vetKeys can be used as signatures issued by the blockchain. This is especially useful for blockchains that don't have a built-in certification feature enabling dapps to sign statements.

It can also be used to efficiently bridge blockchains, e.g., to swap assets in a DeFi application. A dapp on one blockchain can verify signed statements issued by a second blockchain without having to implement a complete light client of that second chain.

### [Identity-based encryption (IBE)](/docs/building-apps/network-features/vetkeys/advanced/identity-based-encryption)

IBE enables encryption directly to a user’s identity. In this model, the dapp controls identity assignment, for example, associating each user with their ICP principal. Each user can then obtain a `vetKey`, which functions as their IBE decryption key, allowing them to decrypt messages or data encrypted to their identity.

Compared to DKMS, IBE works differently. In DKMS, one or more users share **the same** symmetric key, and only those users can encrypt and decrypt data using that key.

In contrast, IBE is an **asymmetric encryption** scheme. Anyone can encrypt messages to a given identity, including other users or canisters, but only the holder of the corresponding decryption key can decrypt them. IBE is more advanced as it builds a full asymmetric encryption system using vetKeys rather than relying solely on symmetric key derivation.

### [Timelock encryption](/docs/building-apps/network-features/vetkeys/advanced/timelock-encryption)

Timelock encryption enables a sender to encrypt a message for the future, ensuring that it will get decrypted at a given time, but no earlier than that time. Timelock encryption can be achieved via IBE by letting the dapp release the IBE decryption keys corresponding to the current time at regular intervals (eventually decrypting the cipher texts in the canister) and letting the sender IBE-encrypt its message using the desired decryption time as identity. More sophisticated timelock conditions are also possible (see below).

#### "Dead man's switch"

Journalists or whistleblowers could ensure that compromising information in their possession is automatically published if they were to become incapacitated. They can store the information in a dapp, encrypted using IBE that the dapp automatically and publicly recovers when a certain amount of time passes after it last received an authenticated ping from its owner.

#### Private auctions and MEV protection

In a private auction dapp, users can submit bids that are IBE-encrypted under an identifier so that at the end of the auction, the dapp can decrypt all bids with a single vetKey evaluation. A similar technique can be used to prevent front-running, also known as miner-extracted value (MEV), on a decentralized exchange (DEX). Users submit their IBE-encrypted transactions under a predictable batch identifier. The DEX orders the transactions in encrypted form and, when all transactions for a particular batch have been ordered, triggers the recovery of the decryption key for that batch and executes the decrypted transactions in the fixed order. Note that all of the symmetric-encryption use cases listed above can be modified to encrypt using an IBE instead of a symmetric-key encryption, thereby eliminating the need to perform a vetKey derivation for encryption. Decryption, of course, still requires retrieving a vetKey.

#### Advanced timelocks

Anyone can IBE-encrypt their message using some more complex condition as identity, while a dapp lets anyone who can satisfy the condition (or when the condition is satisfied on its own) to obtain the respective vetKey. This enables quite interesting use cases, as it enables one to encrypt to any verifiable future event, e.g., the price of a stock going above or below a certain level, information escrow, or break-the-glass policies.

### [Externally verifiable randomness](/docs/building-apps/network-features/vetkeys/advanced/verifiable-randomness)

Because of their uniqueness, vetKeys can also act as a Verifiable Random Function (VRF). Trusted, verifiable randomness is important for applications such as trustless online lotteries and casinos, fair decentralized games (GameFi), and selecting random features for non-fungible tokens (NFTs).

Note that if your dapp does not need external verification (this is normally the case for dapps with public code that are running solely on ICP and no other blockchains), it is more efficient and much cheaper to use secure randomness on ICP that is not externally verifiable, see TODO:LINK.

## vetKeys API

The management canister provides the following low-level API for vetKeys.

```candid
  vetkd_public_key : (record {
    canister_id : opt canister_id;
    context : blob;
    key_id : record { curve : vetkd_curve; name : text };
  }) -> (record { public_key : blob; });
  vetkd_derive_key : (record {
    input : blob;
    context : blob;
    transport_public_key : blob;
    key_id : record { curve : vetkd_curve; name : text };
  }) -> (record { encrypted_key : blob; });
```

The full specification for vetKeys can be found in the [vetKD specification PR](https://github.com/dfinity/portal/pull/3763) (soon to be merged to the [ICP specification](https://internetcomputer.org/docs/references/ic-interface-spec#ic-vetkd_derive_key)).

## Resources

- [vetKeys code libraries](https://github.com/dfinity/vetkd-devkit).

- [Examples of dapps based on vetKeys](https://github.com/dfinity/vetkd-devkit/tree/main/examples).

- [Forum discussion](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560).

- [The first Community Conversation](https://youtu.be/baM6jHnmMq8).

- [vetKeys reference](/docs/references/vetkeys-overview).

- [Research paper](https://eprint.iacr.org/2023/616.pdf).

