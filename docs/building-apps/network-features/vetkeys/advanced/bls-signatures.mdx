---

keywords: [advanced, concept, vetkd, vetkeys, signature, BLS, threshold decryption, encrypted threshold key derivation]

---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import TabItem from "@theme/TabItem";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";

# Threshold BLS signatures

<MarkdownChipRow labels={["Advanced", "BLS signatures"]} />

vetKeys supports distributed signing using the BLS algorithm, which is widely adopted across ICP for its short, unique signatures that are easy to use in distributed systems and fast to compute.

## Signing process

To generate a BLS signature from vetKeys:

1. The canister defines access rules for vetKeys, for example, based on principals.

2. The canister calls the management canister API to produce an encrypted signature.

3. If the signature does not need to be private, the canister can provide a dummy transport key, decrypt the vetKey, and then return the decrypted BLS signature.

4. The canister returns the encrypted signature to the client.

## Application backend

<AdornedTabs groupId="languages">

<TabItem value="rust" label="Rust" default>

The backend of your application can implement a method that signs messages for a caller using the signing BLS key defined by the caller's principal.

TODO: reference code instead of copy-pasting once the PR (currently in review) is merged.

TODO: the signature retrieval should be simplified by implementing vetkey retrieval in the library.

```rust
pub mod types;
use candid::Principal;
use ic_cdk::{query, update};
use ic_stable_structures::{
    memory_manager::{MemoryId, MemoryManager, VirtualMemory},
    DefaultMemoryImpl, StableLog,
};
use ic_vetkd_utils::*;
use serde_bytes::ByteBuf;
use std::{cell::RefCell, str::FromStr};
use types::*;

type Memory = VirtualMemory<DefaultMemoryImpl>;

type VetKeyPublicKey = ByteBuf;
type RawSignature = ByteBuf;
type RawMessage = String;

thread_local! {
    static MEMORY_MANAGER: RefCell<MemoryManager<DefaultMemoryImpl>> =
        RefCell::new(MemoryManager::init(DefaultMemoryImpl::default()));

    static PUBLISHED_SIGNATURES: RefCell<StableLog<Signature, Memory, Memory>> = RefCell::new(StableLog::new(
        MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(0))), // index memory
        MEMORY_MANAGER.with(|m| m.borrow().get(MemoryId::new(1))), // data memory
    ));

    static VETKD_ROOT_IBE_PUBLIC_KEY: RefCell<Option<VetKeyPublicKey>> =  const { RefCell::new(None) };
}

#[update]
async fn sign_message(message: RawMessage) -> RawSignature {
    let signer = ic_cdk::caller();
    // create a transport secret key with a constant seed containing just zeros
    let transport_secret_key =
        TransportSecretKey::from_seed(vec![0; 32]).expect("Failed to create transport secret key");
    let transport_public_key = transport_secret_key.public_key();

    let context = get_context(signer);

    let request = VetKDDeriveKeyRequest {
        input: message.as_bytes().to_vec(),
        context: context.clone(),
        key_id: bls12_381_dfx_test_key(),
        transport_public_key,
    };

    let (VetKDDeriveKeyReply { encrypted_key },) =
        ic_cdk::api::call::call_with_payment128::<_, (VetKDDeriveKeyReply,)>(
            CanisterId::from_str("aaaaa-aa").unwrap(),
            "vetkd_derive_key",
            (request,),
            26_153_846_153,
        )
        .await
        .expect("call to vetkd_derive_key failed");

    let root_public_key_raw = match VETKD_ROOT_IBE_PUBLIC_KEY.with(|v| v.borrow().to_owned()) {
        Some(root_ibe_public_key) => root_ibe_public_key.into_vec(),
        None => get_root_public_key().await.into_vec(),
    };
    let root_public_key = DerivedPublicKey::deserialize(&root_public_key_raw)
        .expect("Failed to deserialize root ibe public key");
    let derived_public_key = root_public_key.derive_sub_key(&get_context(signer));

    let encrypted_key_typed = EncryptedVetKey::deserialize(&encrypted_key)
        .expect("Failed to deserialize encrypted vetkey");

    // decrypt the encrypted vetkey
    let vetkey = encrypted_key_typed
        .decrypt_and_verify(&transport_secret_key, &derived_public_key, message.as_ref())
        .expect("Failed to decrypt and verify vetkey");

    // return the vetkey, which serves as the signature
    vetkey.signature_bytes().to_vec().into()
}

#[update]
fn publish_my_signature_no_verification(message: RawMessage, signature: RawSignature) {
    let signature = Signature {
        message,
        signature: signature.into_vec(),
        timestamp: ic_cdk::api::time(),
        signer: ic_cdk::caller(),
    };
    PUBLISHED_SIGNATURES
        .with_borrow_mut(|log| log.append(&signature))
        .expect("Failed to append signature to log");
}

#[query]
fn get_published_signatures() -> Vec<Signature> {
    PUBLISHED_SIGNATURES.with_borrow(|log| log.iter().collect())
}

#[update]
async fn get_root_public_key() -> VetKeyPublicKey {
    match VETKD_ROOT_IBE_PUBLIC_KEY.with(|v| v.borrow().to_owned()) {
        Some(root_ibe_public_key) => root_ibe_public_key,
        None => {
            let request = VetKDPublicKeyRequest {
                canister_id: None,
                context: vec![],
                key_id: bls12_381_dfx_test_key(),
            };

            let (result,) = ic_cdk::api::call::call::<_, (VetKDPublicKeyReply,)>(
                CanisterId::from_str("aaaaa-aa").unwrap(),
                "vetkd_public_key",
                (request,),
            )
            .await
            .expect("call to vetkd_public_key failed");

            result.public_key.into()
        }
    }
}

fn get_context(signer: Principal) -> Vec<u8> {
    // A domain separator is not strictly necessary in this dapp, but having one is considered a good practice.
    const DOMAIN_SEPARATOR: [u8; 22] = *b"basic_bls_signing_dapp";
    const DOMAIN_SEPARATOR_LENGTH: u8 = DOMAIN_SEPARATOR.len() as u8;
    [DOMAIN_SEPARATOR_LENGTH]
        .into_iter()
        .chain(DOMAIN_SEPARATOR)
        .chain(signer.as_ref().iter().cloned())
        .collect()
}

fn bls12_381_dfx_test_key() -> VetKDKeyId {
    VetKDKeyId {
        curve: VetKDCurve::Bls12_381_G2,
        name: "dfx_test_key".to_string(),
    }
}
```

</TabItem>
</AdornedTabs>

TODO: code snippet and explanation

## Application frontend
<AdornedTabs groupId="languages">
<TabItem value="rs" label="Rust" default>

Alternatively, the frontend of your application can sign message for a caller using the signing BLS key defined by the caller's principal.

TODO: reference code instead of copy-pasting once the PR (currently in review) is merged.

TODO: the `verifySignature` implementation should go to the utils and be just a function call.

```ts
document
  .getElementById("signMessageButton")!
  .addEventListener("click", async () => {
    const message = prompt("Enter message to sign:");
    if (message) {
      try {
        const signature =
          await getBasicBlsSigningCanister().sign_message(message);
        const publish = confirm(
          "Signature generated successfully. Would you like to publish it?",
        );
        if (publish) {
          await getBasicBlsSigningCanister().publish_my_signature_no_verification(
            message,
            signature,
          );
          alert("Signature published successfully!");
        }
      } catch (error) {
        alert(`Error: ${error}`);
      }
    }
  });

async function listSignatures() {
  if (!rootPublicKey) {
    const rootPublicKeyRaw =
      await getBasicBlsSigningCanister().get_root_public_key();
    rootPublicKey = DerivedPublicKey.deserialize(
      Uint8Array.from(rootPublicKeyRaw),
    );
  }

  const signatures =
    await getBasicBlsSigningCanister().get_published_signatures();
  const signaturesDiv = document.getElementById("signatures")!;
  signaturesDiv.innerHTML = "";

  if (signatures.length === 0) {
    signaturesDiv.innerHTML = `
        <div class="no-signatures">
          <p>No signatures have been published yet.</p>
        </div>
      `;
  } else {
    signatures
      .slice()
      .reverse()
      .forEach((signatureData) => {
        const isMe =
          myPrincipal && signatureData.signer.compareTo(myPrincipal) === "eq";
        const signatureHex = Array.from(signatureData.signature)
          .map((b) => b.toString(16).padStart(2, "0"))
          .join("");

        // Convert nanoseconds to milliseconds and create a Date object
        const timestamp = new Date(Number(signatureData.timestamp) / 1_000_000);
        const formattedDate = timestamp.toLocaleString();

        const signatureElement = document.createElement("div");
        signatureElement.className = "signature";
        const isValid = verifySignature(
          signatureData.message,
          Uint8Array.from(signatureData.signature),
          signatureData.signer,
        );
        signatureElement.innerHTML = `
          <h5>Signed message: ${signatureData.message}</h5>
          <p class="principal ${isMe ? "principal-me" : ""}">${signatureData.signer.toString()}</p>
          <p class="signature-hex">${signatureHex}</p>
          <p class="verification-status ${isValid ? "valid" : "invalid"}">Verification: ${isValid ? "Valid" : "Invalid"}</p>
          <p class="timestamp">Added: ${formattedDate}</p>
        `;
        signaturesDiv.appendChild(signatureElement);
      });
  }

  document.getElementById("signaturesList")!.style.display = "block";
  document.getElementById("customSignatureForm")!.style.display = "none";
}

function verifySignature(
  message: string,
  signature: Uint8Array,
  signer: Principal,
): boolean {
  if (!rootPublicKey) {
    throw new Error("Root public key not found");
  }
  const domainSepBytes = new TextEncoder().encode("basic_bls_signing_dapp");
  const domainSetLength = domainSepBytes.length;
  const context = new Uint8Array([
    domainSetLength,
    ...domainSepBytes,
    ...signer.toUint8Array(),
  ]);

  try {
    const signatureG1 = bls12_381.G1.ProjectivePoint.fromHex(signature);
    const negG2 = bls12_381.G2.ProjectivePoint.BASE.negate();
    const dpk = rootPublicKey.deriveKey(context);
    const messageBytes = new TextEncoder().encode(message);
    const msg = augmentedHashToG1(dpk, messageBytes);
    const check = bls12_381.pairingBatch([
      { g1: signatureG1, g2: negG2 },
      { g1: msg, g2: dpk.getPoint() },
    ]);

    const gtOne = bls12_381.fields.Fp12.ONE;

    return bls12_381.fields.Fp12.eql(check, gtOne);
  } catch {
    return false;
  }
}
```

</TabItem>
</AdornedTabs>

## Resources

- [Basic BLS signing dapp](https://todo).
