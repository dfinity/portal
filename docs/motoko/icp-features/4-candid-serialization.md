---
sidebar_position: 4
---

# Candid serialization

[Candid](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/candid-concepts) is an interface description language and serialization format designed specifically for the Internet Computer. It enables different services and canisters to communicate regardless of their programming languages, as Candid provides a [language-agnostic way](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid) to describe and transmit data. It uses [strong typing](https://internetcomputer.org/docs/references/candid-ref) that guarantees accurate data interpretation across services and languages. This type safety is complemented by an efficient binary format for encoding data, making it ideal for network transmission.

When one canister calls another, the arguments are [serialized to Candid](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid), transmitted, and then deserialized by the receiving canister. This standardization enables developers to create frontends in languages like JavaScript that can easily interact with backend canisters written in Motoko or other languages.

Candid's design allows for backwards-compatible upgrades of canister interfaces, facilitating the evolution of services over time. 


## Working with Candid

Motoko provides built-in functions for easy serialization and deserialization of data to and from Candid.

## Autogenerated Candid interfaces

When Motoko code is compiled, a Candid interface file [(`.did`)](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid#the-did-file) for the canister's public methods is automatically generated. This file is used to ensure data passed into and returned from these methods is automatically encoded to and decoded from Candidâ€™s binary format.

Motoko canisters automatically handle the serialization and deserialization of data when the canister interacts with [inter-canister calls or ingress messages](https://internetcomputer.org/docs/building-apps/essentials/message-execution).

## Candid functions

Motoko provides the `to_candid` and `from_candid` functions for serializing and deserializing Candid-encoded data.

There are many different Candid encodings, and thus `Blob`s, for the same value. There is no guarantee that `to_candid` will always return the same `Blob` given the same argument. You should never use them to compare values for equality or compute a hash for a value using its Candid encoding.

Typically, explicit serialization using `to_candid` and `from_candid` isn't necessary in everyday development and is mainly reserved for advanced scenarios, such as dynamic calls to arbitrary canisters, handling binary data for storage, or managing canister upgrades where you explicitly control data encoding.

### `to_candid`

The `to_candid` serializes Motoko values into a Candid-encoded binary `Blob`. This is useful when explicitly encoding data for storage, transmission between canisters, or dynamic inter-canister calls. The `to_candid` function can accept one or multiple arguments separated by commas.

```motoko no-repl
let encoding =  to_candid(true,"hello", 68,-90) //Bool, Text, Nat, Int
```

Each argument must be composed of sharable types. The resulting `Blob` precisely represents the original Motoko values according to Candid specifications.

```motoko no-repl
import Debug "mo:base/Debug";

actor {
  public type User = {
    userId : Nat;
    name : Text;
  };
  
    public func serializeUser(user: User) : async Blob {
        let encodedData : Blob = to_candid(user);
        
        Debug.print("User data serialized successfully.");

        return encodedData;
    };
}
```

### `from_candid`

The `from_candid` function deserializes a Candid-encoded binary `Blob` back into Motoko values. This explicit decoding can be useful when retrieving serialized data for processing or state restoration.

`from_candid` requires clear type context or annotations to decode the `Blob` correctly. The result is wrapped in an optional (`?`) type to handle cases where decoding might fail due to type mismatch or invalid data.

```motoko no-repl
import Debug "mo:base/Debug";

actor {
  public type User = {
    userId : Nat;
    name : Text;
  };

  public func deserializeUser(encodedData : Blob) : async ?User {
    let decodedUser : ?User = from_candid(encodedData);

    switch decodedUser {
      case (?user) {
        Debug.print("User data deserialized successfully.");
        return ?user;
      };
      case null {
        Debug.print("Deserialization failed: Invalid blob or type mismatch.");
        return null;
      };
    };
  };
}
```

## Resources

For more detailed information on Candid, refer to:

- [What is Candid?](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/candid-concepts)
- [Using Candid](https://internetcomputer.org/docs/building-apps/interact-with-canisters/candid/using-candid)
- [Candid Specification](https://internetcomputer.org/docs/references/candid-ref)
