---
keywords: [advanced, tutorial, developer liftoff]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Level 4: Space pilot

<MarkdownChipRow labels={["Advanced", "Tutorial"]} />

- [4.1 Using the ICP ledger](/docs/current/tutorials/developer-liftoff/level-4/4.1-icp-ledger): In this tutorial, you'll dive into how to deploy a local instance of the ICP ledger canister and how to interact with it:
    - Accounts.
    - Transaction types.
    - Deploying the ICP ledger locally.
        - Prerequisites.
        - Creating a new project.
        - Locating the Wasm and Candid files.
        - Creating a `minting` account.
        - Deploying the canister.
    - Interacting with the ICP ledger canister.
        - Using `dfx ledger`.
        - Using `dfx canister`.
        - Using the Candid UI.
    - Resources.

- [4.2 ICRC-1 tokens](/docs/current/tutorials/developer-liftoff/level-4/4.2-icrc-tokens): For developers to create their own fungible tokens on the Internet Computer, the ICRC-1 token standard can be used. For this tutorial, you'll focus on the ICRC-1 standard, ICRC-1 ledger, and briefly look into the ICRC-2 standard:
    - What’s the difference between the ICP and ICRC-1 ledgers?
        - `Account`s versus `AccountIdentifier`s.
        - Endpoints.
    - Index canisters.
    - Extensions of the standard.
    - Metadata.
    - Deploying the ICRC-1 ledger locally.
        - Prerequisites.
        - Creating a new project.
        - Locating the Wasm and Candid files.
        - Deploying the ICRC-1 ledger on the mainnet.
    - Interacting with the ICRC-1 ledger.
        - Using the `dfx canister` command with ICRC-1 endpoints.
        - Using ICRC-2 endpoints.
        - Using the Candid UI.
    - Resources.

- [4.3 ckBTC and Bitcoin integration](/docs/current/tutorials/developer-liftoff/level-4/4.3-ckbtc-and-bitcoin): One of the key features of the Internet Computer is known as **chain-key cryptography**. This feature enables integrations with other networks, such as the Bitcoin network. This tutorial takes a look at ckBTC and the Internet Computer's Bitcoin integration:
    - Bitcoin integration architecture.
    - What is ckBTC?
    - Bitcoin use cases on ICP.
    - Deploying a Bitcoin dapp.
        - Prerequisites.
        - Setting up a local Bitcoin network.
        - Cloning the `basic_bitcoin` example.
        - Deploying the example canister.
        - Generating a Bitcoin address.
        - Receiving BTC.
        - Checking your BTC balance.
        - Sending BTC.
    - Resources.

- [4.4 NNS governance and staking](/docs/current/tutorials/developer-liftoff/level-4/4.4-nns-governance): The Network Nervous System (NNS) is the governing body of the Internet Computer. It is a decentralized autonomous organization that is hosted fully onchain and is responsible for making protocol-level upgrades to ICP:
    - What is the NNS?
        - Neurons.
        - Proposals.
    - Why is the NNS important to developers?
    - What is an SNS?
        - How an SNS works.
        - SNS decentralization swaps.
        - SNS resources.
    - Using the NNS dapp.
        - Transferring ICP tokens into your Internet Identity `Main` account.
        - Staking ICP in a neuron.
        - Interacting with NNS proposals.

- [4.5 Using quill](/docs/current/tutorials/developer-liftoff/level-4/4.5-using-quill): Quill is a ledger and governance toolkit that provides support for self-custody of ICP tokens and functionality to interact with the NNS, SNSs, and ICP ledger from a **cold wallet**:
    - What is quill?
    - Downloading and installing quill.
    - Using quill’s basic commands.
    - Using quill with ckBTC.
    - Using quill with the NNS.
    - Resources.

- [4.6 Motoko level 4](/docs/current/tutorials/developer-liftoff/level-4/4.6-motoko-lvl4): In this final Motoko module of the developer liftoff series, we'll cover the following Motoko concepts and components:
    - Mutable state.
        - Immutable variables versus mutable variables.
        - Reading data from mutable memory.
        - Immutable arrays.
        - Mutable arrays.
    - Local objects and classes.
        - Object classes versus actor classes.
        - Object types.
        - Object subtyping.
        - Object classes.
        - Data arguments.
    - Message inspection.
    - Errors and options.
        - Error handling best practices.
        - Error reporting with `Option` values.
        - Error reporting with `Result` variants .
        - Asynchronous errors.
    - Resources.
