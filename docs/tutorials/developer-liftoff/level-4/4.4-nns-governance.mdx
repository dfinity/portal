---
keywords: [advanced, tutorial, developer liftoff, nns, governance, sns, how to use nns, how to create sns, using the nns, using an sns]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# 4.4 NNS governance and staking

<MarkdownChipRow labels={["Advanced", "Tutorial"]} />

<div class="text--center">
<p> </p>
</div>
<div class="text--center">
<iframe width="660" height="415" src="https://www.youtube.com/embed/iDxTRDzHDoQ?si=_Nyz568zwZC2jkoE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe> </div>

When blockchain networks need to be upgraded, traditionally they use a method known as a 'hard fork,' which involves substantial work and manual coordination. In comparison, ICP upgrades itself weekly, which can be seen on the [ICP dashboard](https://dashboard.internetcomputer.org/releases).

## What is the NNS?

The Network Nervous System (NNS) is the governing body of ICP. It is a decentralized autonomous organization (DAO) that is hosted fully onchain and is responsible for making protocol-level upgrades to ICP. The goal of the NNS is to allow ICP to be governed in a secure, open, and decentralized way. Some examples of upgrades made to ICP through the NNS are:

- Upgrade the protocol and software used by the network's node machines.

- Create new subnets.

- Split and divide subnets.

- Configure economic parameters that control how much users pay for resources.

Each upgrade made to ICP is first introduced as an NNS proposal. When an NNS proposal is submitted, the network participants vote on whether to adopt the proposed changes or reject them. Voting is done via a liquid democracy, where ICP holders can stake ICP within a voting neuron in return for voting power.

### Neurons

Neurons are entities that hold ICP tokens in return for voting power and voting rewards on the NNS. ICP tokens that are staked within a neuron cannot be immediately withdrawn; neurons require a notice be given first, known as the neuron's "dissolve delay."

The dissolve delay determines how long the neuron will take to dissolve if it is placed into "dissolve mode." Once dissolved, the neuron owner can unlock the staked balance of ICP. This incentives neuron owners to vote with a long-term view focused on maximizing their ICP's value at a later date. Neuron owners can configure higher dissolve delays up to a maximum of eight years, but cannot decrease it below the natural passage of time.

A neuron's voting power is proportional to the quantity of ICP staked within it, the length of its dissolve delay, and the amount of time since the neuron was created. Neurons can be configured to vote automatically or manually. To vote automatically, the neuron can be configured to follow the voting decision of a group of neurons, where it decides to approve a proposal if more than half of the followed group approves or rejects the proposal if more than half of the followed group rejects. Voting automatically can be useful for neuron owners who may not have the necessary time to evaluate each proposal or who do not fully understand a proposal's details.

Anyone holding ICP can create a neuron and is encouraged to do so through reward incentives. Reward amounts are determined by the amount of ICP locked in the neuron, the neuron's dissolve delay time, the neuron's age, and the proportion of possible votes that it participated in to the sum of total voting activity across all neurons. Rewards are distributed this way because the total reward pool is a capped value that is divided between all NNS voters.

Neurons can also submit new proposals to the NNS. To prevent neurons from spamming proposals, a fee of 25 ICP is charged to the neuron if their submitted proposal is rejected.

[Learn more about neurons and their attributes](/docs/building-apps/governing-apps/nns/concepts/neurons/neuron-overview).

### Proposals

If a proposal has a majority approval, it will be accepted and autonomously executed. Proposals each adhere to a specific proposal type, which defines what information the proposal includes. For each proposal type, the NNS maintains a corresponding system function, which is executed using the proposal's content to fill the function's parameters whenever a proposal of that type is approved and adopted. Each proposal type belongs to a proposal topic, such as "#NetworkEconomics" or "#NodeAdmin."

Each NNS proposal contains the following fields:

- Summary: A field of text that describes the proposal.

- URL: The web address of any additional content that is required to evaluate the proposal.

- Proposer: The ID of the neuron that submitted the proposal.

- Proposal type: The type of proposal and what topic it belongs to.

- Parameters: Any parameters that will be passed to the system function that is executed if the proposal is approved.

- Unique identity: A unique identity value the NNS assigns to each proposal it receives.

[View detailed information about different proposal types and topics](/docs/building-apps/governing-apps/nns/concepts/neurons/neuron-overview).

## Why is the NNS important to developers?

For developers who are focused on building their own dapps and projects, you may be asking, "Why does the NNS matter to me?"

There are several reasons that all users and developers on ICP should be familiar with and take part in the governance of the network through the NNS, but for developers specifically, these reasons include:

- Developers who stake ICP in a neuron and receive voting rights can have a direct say in whether they agree or disagree with a proposed change or feature and can vote on the proposal accordingly.

- Neuron owners have the ability to submit proposals to introduce features or changes that may enhance their workflow or enable new functionality.

- Neurons that regularly vote on proposals receive rewards in the form of ICP tokens, which can be converted into cycles and then used to pay for a project's resources on the mainnet.

- Gaining a comprehensive understanding of the NNS and SNSes allows you to envision creating an SNS for your project.

For additional information on the NNS dapp, proposals, and neuron staking, check out the [NNS quick start guide](/docs/building-apps/governing-apps/nns/using-the-nns-dapp/nns-app-quickstart) and the [NNS explained series](https://youtu.be/1uX-fRgvXjU?feature=shared).

## What is an SNS?

A Service Nervous System (SNS) is an advanced form of a DAO. The underlying architecture of an SNS closely resembles the architecture of the NNS, but instead of being used to control ICP, an SNS is used to control a specific decentralized application that is running on the mainnet. Any dapp running on the mainnet can be handed over to an SNS, which results in the dapp being owned and controlled by a community. When an SNS is launched, a new unique token is created for the SNS that is then used by the community for participation in the SNS's governance.

The dapp's community can participate in the SNS through staking the SNS's native token in a neuron. Then, changes to the dapp are proposed to the community via an SNS proposal. SNS voting rights use the same format that voting on the NNS does; anyone can stake the SNS's native token into a neuron, and the neuron's voting power is proportional to the quantity of SNS tokens staked within the neuron, the length of their dissolve delay, and the amount of time since the neuron was created.

You can learn more about SNSes in the following resources:

* [SNS overview page](https://internetcomputer.org/sns).

* [Service Nervous System (SNS) developer docs](/docs/building-apps/governing-apps/overview).

* [SNS FAQ](https://internetcomputer.org/sns/faq).

### How an SNS works

While the core architecture of an SNS resembles that of the NNS, the NNS contains additional canisters that provide important functionalities on ICP, such as the cycles minting canister that is responsible for creating cycles, or the registry canister that contains the network's topology. In contrast, an SNS contains a few canisters that do not exist on the NNS, with the most notable canister being the swap canister used during the launch of the SNS.

SNSes are provided as a system functionality. All SNS canister code is approved by the NNS community, and thus all SNSes follow the same upgrade path. Launching a new SNS is also approved by the NNS community, including the initial settings of the SNS and the conditions of the decentralization swap.

An SNS is comprised of the following canisters:

- SNS governance canister.

- SNS [ledger](/docs/building-apps/governing-apps/launching/integrating) and archive canisters.

- SNS [index](/docs/building-apps/governing-apps/launching/integrating) canister.

- SNS root canister.

- SNS decentralization swap canister.

[Learn more about SNS architecture](/docs/building-apps/governing-apps/overview).

### SNS decentralization swaps

In order for an SNS to be launched, the SNS must have a successful decentralization swap. A decentralization swap is the action of initially funding the SNS by swapping ICP tokens for the SNS's native token. The decentralization swap is done through the SNS decentralization swap canister, which is controlled by the NNS root canister.

When the swap starts, there is a pre-defined amount of SNS tokens to be distributed publicly. During the swap, participants can send ICP tokens to the swap canister to contribute to the SNS's initial funding.

When the swap ends, the collected ICP tokens are swapped for the SNS's tokens. Participants that sent ICP tokens to the swap canister receive SNS tokens in the form of SNS neurons. The amount they receive is pro-rated by the amount of ICP tokens they contributed to the overall amount of ICP collected in the swap. For example, if the swap canister initially held 1000 SNS tokens, and 500 ICP tokens were collected during the swap, the exchange rate would be 2:1, meaning each participant would receive 2 tokens for each ICP token they contributed.

The SNS places the collected ICP into an SNS-controlled treasury. After a successful swap, the SNS tokens are owned by its community.

You can learn more about SNS tokenomics and rewards in the following resources:

* [SNS tokenomics](/docs/building-apps/governing-apps/tokenomics/tokenomics-intro).

* [SNS rewards](/docs/building-apps/governing-apps/tokenomics/rewards).

## SNS resources

To learn more about creating, launching, and managing an SNS, refer to the following resources:

* [SNS launch](/docs/building-apps/governing-apps/launching/launch-summary-1proposal).

* [An introduction to SNS preparation](/docs/building-apps/governing-apps/tokenomics/).

* [The SNS launch checklist](/docs/building-apps/governing-apps/tokenomics/sns-checklist).

* [Pre-deployment considerations](/docs/building-apps/governing-apps/tokenomics/predeployment-considerations).

* [SNS parameters](/docs/building-apps/governing-apps/tokenomics/preparation).

* [Guidelines on how to test an SNS locally](/docs/building-apps/governing-apps/testing/testing-locally).

* [Guidelines on how to test the operation of the dapp under SNS control](/docs/building-apps/governing-apps/testing/testing-on-mainnet).

* [Stages included in an SNS launch](/docs/building-apps/governing-apps/launching/launch-summary-1proposal).

* [SNS proposals](/docs/building-apps/governing-apps/managing/making-proposals).

* [Tips regarding cycles management for the canisters](/docs/building-apps/governing-apps/managing/cycles-usage).

* [An introduction to how to use the asset canister with an SNS-controlled dapp](/docs/building-apps/governing-apps/managing/sns-asset-canister).

import TutorialFooter from "@site/src/components/TutorialFooter/";

<TutorialFooter />
