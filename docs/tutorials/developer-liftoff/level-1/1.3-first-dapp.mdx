---
keywords: [beginner, tutorial, developer liftoff, first dapp]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import '/src/components/CenterImages/center.scss';
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# 1.3 Developing your first dapp

<MarkdownChipRow labels={["Beginner", "Tutorial"]} />

<div class="text--center">
<p> </p>
</div>
<div class="text--center">
<iframe width="660" height="415" src="https://www.youtube.com/embed/nUB7_KjE-uU?si=TRqLKWJqJ-apPVxo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe> </div>

:::caution
The video corresponding to this tutorial is outdated and follows a different project structure than what is written on this page.
:::

At this point in your developer liftoff, you've covered the fundamentals of <GlossaryTooltip>canister</GlossaryTooltip> development and deployed the default 'Hello, world' project template on the playground. It's time to get into writing code and developing your first dapp!

For this tutorial, you'll be creating a simple LLM chat bot dapp that includes both a backend canister and a frontend canister. To recap, backend canisters are used to host the dapp's smart contract code, while frontend canisters are used to host user interface assets, such as HTML and CSS.

This tutorial will demonstrate how to create a dapp [using ICP Ninja](https://icp.ninja/projects/llm-chatbot). Alternatively, you can create a new project with `dfx` or download the project's files from ICP Ninja and deploy it locally.

Through ICP Ninja, you can deploy applications to the mainnet for free. Although applications deployed through ICP Ninja are temporary and will be removed after 20 minutes, but they do not cost [cycles](/docs/building-apps/getting-started/tokens-and-cycles), making it valuable tool for getting started quickly.

## Opening the project

First, navigate to [ICP Ninja](https://icp.ninja/projects/llm-chatbot) and select the 'Motoko' option for the LLM chat bot template. Then select 'Open project.'

Let's review the project's file structure:

```bash
llm_bot ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† # The root of the project.
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ dfx.json ¬† ¬† ¬† ¬† ¬† # The configuration file for your Internet Computer dapp.
‚îú‚îÄ‚îÄ src
‚îÇ ¬† ‚îú‚îÄ‚îÄ backend ¬† # Folder containing the source code of your dapp's backend.
‚îÇ ¬† ‚îÇ ¬† ‚îî‚îÄ‚îÄ app.mo ¬† ¬†# The default source code file; this is what you'll primarily be working with in this tutorial.
‚îÇ ¬† ‚îî‚îÄ‚îÄ frontend ¬†# Folder containing the frontend configuration and assets of your dapp.
‚îÇ ¬† ¬† ¬† ‚îî‚îÄ‚îÄ assets
|         ‚îî‚îÄ‚îÄ public
|         ‚îî‚îÄ‚îÄ src
|         ‚îî‚îÄ‚îÄ index.html
```

## Reviewing the backend canister code

```motoko title="backend/app.mo" no-repl
import LLM "mo:llm";

persistent actor {
  public func prompt(prompt : Text) : async Text {
    await LLM.prompt(#Llama3_1_8B, prompt);
  };

  public func chat(messages : [LLM.ChatMessage]) : async Text {
    await LLM.chat(#Llama3_1_8B, messages);
  };
};
```

:::info
**What does this code do?**

First, the code imports the `LLM` package from `mo:llm`. Next, it creates an actor. Recall that an actor is a process with an encapsulated state. Actors contain both code and data and communicate by sending and receiving messages. A canister can only contain a single actor.

Then, two functions are defined:

- `prompt`: A public function that takes an input of `Text` and returns an output of `Text`. It makes a call to the LLM to generate a response base on the `Text` passed to the function.

- `chat`: A public function that is used to continue the conversation after the first initial prompt.
:::

## Reviewing the frontend code

In this example, the application's frontend contains the following asset files:

```
‚îú‚îÄ‚îÄ frontend
‚îÇ ¬† ‚îú‚îÄ‚îÄ public
‚îÇ ¬† ¬† ¬† ‚îî‚îÄ‚îÄ bot.svg
‚îÇ ¬† ¬† ¬† ‚îî‚îÄ‚îÄ favicon.ico
‚îÇ ¬† ¬† ¬† ‚îî‚îÄ‚îÄ user.svg
‚îÇ ¬† ‚îú‚îÄ‚îÄsrc
‚îÇ ¬† ¬† ¬† ‚îî‚îÄ‚îÄ main.jsx
‚îÇ ¬† ‚îú‚îÄ‚îÄ index.css
‚îÇ ¬† ‚îú‚îÄ‚îÄ index.html
‚îÇ ¬† ‚îú‚îÄ‚îÄ package.json
‚îÇ ¬† ‚îú‚îÄ‚îÄ postcss.config.js
‚îÇ ¬† ‚îú‚îÄ‚îÄ tailwind.config.js
‚îÇ ¬† ‚îú‚îÄ‚îÄ vite.config.js
```

In these files, `main.jsx` contains the code necessary for the frontend to communicate with the backend.

```javascript title="frontend/src/main.jsx"
import React, { useState, useRef, useEffect } from 'react';
import ReactDOM from 'react-dom/client';
import { backend } from 'declarations/backend';
import botImg from '/bot.svg';
import userImg from '/user.svg';
import '/index.css';

const App = () => {
  const [chat, setChat] = useState([
    {
      role: { system: null },
      content: "I'm a sovereign AI agent living on the Internet Computer. Ask me anything."
    }
  ]);
  const [inputValue, setInputValue] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const chatBoxRef = useRef(null);

  const formatDate = (date) => {
    const h = '0' + date.getHours();
    const m = '0' + date.getMinutes();
    return `${h.slice(-2)}:${m.slice(-2)}`;
  };

  const askAgent = async (messages) => {
    try {
      const response = await backend.chat(messages);
      setChat((prevChat) => {
        const newChat = [...prevChat];
        newChat.pop();
        newChat.push({ role: { system: null }, content: response });
        return newChat;
      });
    } catch (e) {
      console.log(e);
      const eStr = String(e);
      const match = eStr.match(/(SysTransient|CanisterReject), \\+"([^\\"]+)/);
      if (match) {
        alert(match[2]);
      }
      setChat((prevChat) => {
        const newChat = [...prevChat];
        newChat.pop();
        return newChat;
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (!inputValue.trim() || isLoading) return;

    const userMessage = {
      role: { user: null },
      content: inputValue
    };
    const thinkingMessage = {
      role: { system: null },
      content: 'Thinking ...'
    };
    setChat((prevChat) => [...prevChat, userMessage, thinkingMessage]);
    setInputValue('');
    setIsLoading(true);
    const messagesToSend = chat.slice(1).concat(userMessage);
    askAgent(messagesToSend);
  };

  useEffect(() => {
    if (chatBoxRef.current) {
      chatBoxRef.current.scrollTop = chatBoxRef.current.scrollHeight;
    }
  }, [chat]);

  return (
    <div className="flex min-h-screen items-center justify-center bg-gray-50 p-4">
      <div className="flex h-[80vh] w-full max-w-2xl flex-col rounded-lg bg-white shadow-lg">
        <div className="flex-1 overflow-y-auto rounded-t-lg bg-gray-100 p-4" ref={chatBoxRef}>
          {chat.map((message, index) => {
            const isUser = 'user' in message.role;
            const img = isUser ? userImg : botImg;
            const name = isUser ? 'User' : 'System';
            const text = message.content;

            return (
              <div key={index} className={`flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`}>
                {!isUser && (
                  <div
                    className="mr-2 h-10 w-10 rounded-full"
                    style={{ backgroundImage: `url(${img})`, backgroundSize: 'cover' }}
                  ></div>
                )}
                <div className={`max-w-[70%] rounded-lg p-3 ${isUser ? 'bg-blue-500 text-white' : 'bg-white shadow'}`}>
                  <div
                    className={`mb-1 flex items-center justify-between text-sm ${isUser ? 'text-white' : 'text-gray-500'}`}
                  >
                    <div>{name}</div>
                    <div className="mx-2">{formatDate(new Date())}</div>
                  </div>
                  <div>{text}</div>
                </div>
                {isUser && (
                  <div
                    className="ml-2 h-10 w-10 rounded-full"
                    style={{ backgroundImage: `url(${img})`, backgroundSize: 'cover' }}
                  ></div>
                )}
              </div>
            );
          })}
        </div>
        <form className="flex rounded-b-lg border-t bg-white p-4" onSubmit={handleSubmit}>
          <input
            type="text"
            className="flex-1 rounded-l border p-2 focus:outline-none focus:ring-2 focus:ring-blue-500"
            placeholder="Ask anything ..."
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            disabled={isLoading}
          />
          <button
            type="submit"
            className="rounded-r bg-blue-500 p-2 text-white hover:bg-blue-600 disabled:bg-blue-300"
            disabled={isLoading}
          >
            Send
          </button>
        </form>
      </div>
    </div>
  );
};

export default App;

ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
```

## How does the frontend communicate with the backend?

The frontend canister is essentially a web server hosting a website. When a user loads the application, the web browser fetches the user interface from the frontend canister. Once the frontend is loaded into the browser, the user can interact with it, triggering messages to be sent to the backend.

<div class="text--center">
¬† <img
¬† ¬† src={useBaseUrl("/img/docs/app-flow.png")}
¬† ¬† alt="Application flow"
¬† ¬† width="800"
¬† />
</div>

In this script, the backend declarations are imported with `import { backend } from 'declarations/backend';`. Declaration files define the public methods of a canister and their input and output types. For this application, the declarations file will include the backend's `prompt` and `chat` methods and their `Text` input and output types. Declaration files are generated by `dfx` during the build process. If you build this project locally, you will see them; they are now shown in the ICP Ninja file viewer.

When the agent makes a call to the backend canister, it uses these declaration files to determine which public methods it can submit requests to. Then it will create and send the request containing the request type, canister ID, method name, and any input or arguments to be passed to the method.

In this example, the user interface includes a text input box and a button to submit the chat input. When the button is pressed, the ICP JavaScript agent sends a request to the `backend` canister's `prompt` method that includes the user's text input, which passes the input to the LLM to generate a response.

The backend processes the request, then responds to the agent with an outgoing message that includes the result of the method.

## Deploy and test

To deploy this app in ICP Ninja, select the 'Deploy' button in the upper right corner of the IDE. In the build logs, you will see the build process:

```
Deploying code onchain...
‚Üí Reserving canisters onchain
‚Üí Building backend
‚Üí Building frontend
‚Üí Uploading frontend assets
Backend Internet Computer URL:
https://a4gq6-oaaaa-aaaab-qaa4q-cai.icp1.io/?id=6yq5h-4aaaa-aaaab-qbmfa-cai
ü•∑üöÄüéâ Your dapp's Internet Computer URL is ready:
https://7azie-saaaa-aaaab-qbmba-cai.icp1.io
‚è∞ Your dapp will be available for 20 minutes
```

Open the second URL, in this example `https://7azie-saaaa-aaaab-qbmba-cai.icp1.io`, to view the application deployed on the mainnet.

<div class="text--center">
¬† <img
¬† ¬† src={useBaseUrl("/img/docs/llm-bot.png")}
¬† ¬† alt="LLM Chat bot example"
¬† ¬† width="800"
¬† />
</div>

To test out your dapp, give it a prompt such as "What is the Internet Computer?"

<div class="text--center">
¬† <img
¬† ¬† src={useBaseUrl("/img/docs/llm-bot2.png")}
¬† ¬† alt="LLM Chat bot example"
¬† ¬† width="800"
¬† />
</div>

Want to share your new dapp with a friend? Simply send them the frontend canister's URL, such as: `https://7azie-saaaa-aaaab-qbmba-cai.icp1.io`

## Need help?

Did you get stuck somewhere in this tutorial, or feel like you need additional help understanding some of the concepts? The ICP community has several resources available for developers, like working groups and bootcamps, along with our Discord community, forum, and events such as hackathons. Here are a few to check out:

- [Developer Discord](https://discord.internetcomputer.org), which is a large chatroom for ICP developers to ask questions, get help, or chat with other developers asynchronously via text chat.

- [Developer liftoff forum discussion](https://forum.dfinity.org/t/developer-journey-feedback-and-discussion/23893).

- [Developer tooling working group](https://www.google.com/calendar/event?eid=MHY0cjBubmlnYXY1cTkzZzVzcmozb3ZjZm5fMjAyMzEwMDVUMTcwMDAwWiBjX2Nnb2VxOTE3cnBlYXA3dnNlM2lzMWhsMzEwQGc&ctz=Europe/Zurich).

- [Motoko Bootcamp - The DAO Adventure](https://github.com/motoko-bootcamp/dao-adventure) - Discover the Motoko language in this 7 day adventure and learn to build a DAO on the Internet Computer.

- [Motoko Bootcamp - Discord community](https://discord.gg/YbksCUxdzk) - A community for and by Motoko developers to ask for advice, showcase projects and participate in collaborative events.

- [Motoko developer working group](https://www.google.com/calendar/event?eid=ZWVnb2luaHU0ZjduMTNpZHI3MWJkcWVwNWdfMjAyMzEwMTJUMTUwMDAwWiBjX2Nnb2VxOTE3cnBlYXA3dnNlM2lzMWhsMzEwQGc&ctz=Europe/Zurich).

- [Upcoming events and conferences](https://dfinity.org/events-and-news/).

- [Upcoming hackathons](https://dfinity.org/hackathons/).

- Weekly developer office hours to ask questions, get clarification, and chat with other developers live via voice chat. This is hosted on the [Discord](https://discord.internetcomputer.org) server.

- Submit your feedback to the [ICP Developer feedback board](https://dx.internetcomputer.org).

## Next steps

In this tutorial, you only deployed our dapp to your local environment. In the next module, you'll acquire <GlossaryTooltip>cycles</GlossaryTooltip> in order for you to deploy your dapp to the Internet Computer mainnet.

- [1.4 Acquiring and using cycles](/docs/tutorials/developer-liftoff/level-1/1.4-using-cycles).
