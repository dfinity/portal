---
keywords: [beginner, getting started, tutorial, hello world, writing code, writing smart contracts, write, smart contracts, write code]
---

import TabItem from "@theme/TabItem";
import useBaseUrl from "@docusaurus/useBaseUrl";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# Write smart contracts

<MarkdownChipRow labels={["Beginner", "Getting started", "Tutorial"]} />

## Overview

Canisters are an enhanced type of smart contract. Before a canister is deployed to ICP, the canister's code is compiled into a WebAssembly (Wasm) program, providing it with the ability to store persistent data, be managed by entities such as DAOs, host entire applications, and more. Each canister has the following components:

<div class="text--center">
<img src="/img/docs/inside-canister.png" alt="Canister" width="600"/>
</div>

[Learn more about each component of a canister](/docs/current/developer-docs/smart-contracts/overview/inside-canisters).

## Canister development kits (CDKs)

A canister development kit (CDK) can be used to write the code for a canister. CDKs provide build scripts that compile the canister code into Wasm programs that are compatible with ICP.

Available CDKs include:

- [Motoko](/docs/current/motoko/main/getting-started/motoko-introduction): ICP's native programming language. By default, Motoko is installed with the IC SDK.

- [Rust CDK](https://github.com/dfinity/cdk-rs): By default, the Rust CDK is included as a dependency of the IC SDK. Alternatively, you can [install it yourself](https://crates.io/crates/ic-cdk).

- [Kybra: Python CDK](/docs/current/developer-docs/backend/python/)  <span style={{ display: 'inline-block', verticalAlign: 'super' }}><BetaChip /></span>  : Learn more about how to [install and use Azle](/docs/current/developer-docs/backend/typescript/).

- [Azle: TypeScript CDK](/docs/current/developer-docs/backend/typescript/)  <span style={{ display: 'inline-block', verticalAlign: 'super' }}><BetaChip /></span>  : Learn more about how to [install and use Kybra](/docs/current/developer-docs/backend/python/).

- [Bitfinity EVM for Solidity](/docs/current/developer-docs/backend/solidity/)  <span style={{ display: 'inline-block', verticalAlign: 'super' }}><BetaChip /></span>  : Learn more about how to use the [Bitfinity EVM](https://docs.bitfinity.network/ic-agent/overview).

- [C++ CDK](https://docs.icpp.world/): Supported through the [ICPP-pro CDK](https://docs.icpp.world/installation.html).

## Creating a project

Before you can begin writing canister code, you need to create a project.

<AdornedTabs>
<TabItem value="create-new" label="Create a new project" default={true}>

If you did not download an [ICP Ninja](/docs/current/developer-docs/getting-started/explore-examples) project, or if you would like to create a new project, run:

```
dfx new PROJECT_NAME --type=motoko
cd PROJECT_NAME
```

Options for the `--type` flag are `motoko`, `rust`, `azle`, `kybra`.

:::caution
Using [Rust](/docs/current/developer-docs/backend/rust/dev-env), [Azle](/docs/current/developer-docs/backend/typescript/), or [Kybra](/docs/current/developer-docs/backend/python/) may require additional dependencies be installed if you have not developed with those languages in your environment before. View their corresponding documentation for more information.
:::

</TabItem>
<TabItem value="use-ninja" label="Use an ICP Ninja project">

Navigate into the directory where you downloaded your [ICP Ninja](/docs/current/developer-docs/getting-started/explore-examples) project using a command like:

```
cd /path/to/icp/ninja/project
```

</TabItem>
</AdornedTabs>

You should be in a directory that contains a file called `dfx.json`. This file is used to configure your project's settings. It includes the project's canister definitions, such as the canister's type, source code file, and dependencies.

```json title=dfx.json
{
  "canisters": {
    "PROJECT_NAME_backend": { // Backend canister name
      "main": "src/PROJECT_NAME_backend/main.mo", // Backend canister source code
      "type": "motoko" // Canister language
    },
    "PROJECT_NAME_frontend": { // Frontend canister name
      "dependencies": [
        "PROJECT_NAME_backend"
      ],
      "source": [
        "src/PROJECT_NAME_frontend/dist" // Frontend canister source code
      ],
      "type": "assets", // All frontend canisters will be type 'assets' regardless of the frontend framework used
      "workspace": "PROJECT_NAME_frontend"
    }
  },
  "defaults": {
    "build": {
      "args": "",
      "packtool": ""
    }
  },
  "output_env_file": ".env",
  "version": 1
}
```

## Default project architecture

The default project architecture used by `dfx new` and ICP Ninja projects contains two canisters, a `backend` and a `frontend`.

The `backend` canister is used to store the dapp's functions and core logic.

The `frontend` canister is used to store the dapp's frontend assets. This includes files such as HTML, CSS, JavaScript, React, images, and videos.

<div class="text--center">
  <img
    src={useBaseUrl("/img/docs/default-dapp-arch.png")}
    alt="Application architecture"
    width="800"
  />
</div>

## Writing code

:::danger

This section will focus on writing backend canister code. If you want to explore some examples with application frontends, [view the ICP Ninja projects](https://icp.ninja).

:::

### Prerequisites

- [x] Download and install an IDE or code editor. [VS Code](https://code.visualstudio.com/) is recommended.

:::tip

For writing Motoko code, the [Motoko VS Code extension](https://marketplace.visualstudio.com/items?itemName=dfinity-foundation.vscode-motoko) is highly recommended for syntax highlighting.

:::

### 1. Open the backend canister source code file in your code editor.

For Motoko projects, this file will be `src/PROJECT_NAME_backend/main.mo`.

For Rust projects, this file will be `src/PROJECT_NAME_BACKEND/src/lib.rs`.

For [Azle](https://demergent-labs.github.io/azle/get_started.html) or [Kybra](https://demergent-labs.github.io/kybra/) projects, please refer to their respective documentation for details about their default code files.

If you are using the default template created by `dfx`, you will see the following default code:

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```motoko title="src/PROJECT_NAME_backend/main.mo"
actor {
public query func greet(name : Text) : async Text {
    return "Hello, " # name # "!";
  };
};
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust title="src/PROJECT_NAME_backend/src/lib.rs"
#[ic_cdk::query]
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}
```

</TabItem>
</AdornedTabs>

:::danger

If you are using the default `dfx new` template, this will be a simple "Hello, world!" application.

If you are using an ICP Ninja project, this code will vary based on the example you downloaded.

:::

### 2. Add randomness

A key feature of ICP is its ability to generate [onchain randomness](/docs/current/developer-docs/smart-contracts/advanced-features/randomness) using a Verifiable Random Function (VRF) and [chain-key cryptography](https://internetcomputer.org/how-it-works/chain-key-technology). In each round of consensus on a subnet, the VRF is evaluated using the number of the round as input, producing a fresh set of random bytes. Then, the bytes are used as the seed for a pseudorandom number generator (PRNG), called random tape, which uses chain-key cryptography to create a random, unique value for each canister that requests it. Through this process, it is impossible to predict future outputs.

To use randomness in your application, you need to make a call to the `raw_rand` method of the [management canister](/docs/current/developer-docs/smart-contracts/advanced-features/management-canister).

To demonstrate how to use randomness, you will create a simple app that generates a random number.

Remove the existing code in your backend source code file. Then, insert the following:

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```motoko title="src/PROJECT_NAME_backend/main.mo"
import Timer "mo:base/Timer";
import Nat8 "mo:base/Nat8";
import Debug "mo:base/Debug";
import Blob "mo:base/Blob";
import Nat "mo:base/Nat";

actor {
    // Create a stable variable to store the current random number.
    // Stable variables persist across canister upgrades.
    stable var currentRandomNumber : Nat = 0;

    // The management canister's principal ID is "aaaaa-aa".
    // This code provides the logic to call the raw_rand method of the management canister.
    let SubnetManager : actor {
      raw_rand() : async Blob;
    } = actor "aaaaa-aa";

    // Create a function to generate a new random number.
    // This function calls the raw_rand method of the management canister.
    // Then it uses the random bytes returned to generate a random number.
    private func generateNewNumber() : async () {
        let randomBytes = await SubnetManager.raw_rand();
        if (randomBytes.size() > 0) {
            // Use the first byte to generate a number between 0 and 255
            let bytes : [Nat8] = Blob.toArray(randomBytes);
            currentRandomNumber := Nat8.toNat(bytes[0]);
            Debug.print("Generated new random number: " # Nat.toText(currentRandomNumber));
        };
    };

    // Use a query call to get current random number.
    public query func getCurrentNumber() : async Nat {
        currentRandomNumber
    };
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust title="src/PROJECT_NAME_backend/src/lib.rs"


```

</TabItem>
</AdornedTabs>


### 3. Add a timer.

At this point, the canister code generates a single random number and stores it in a variable. You can retrieve that value with a query function. To demonstrate another feature of ICP, let's add a timer that generates a new random number every 5 seconds.

Timers are used to automatically execute actions after a specified interval or delay, enabling canisters to perform autonomous tasks.

Add the following highlighted line to your backend code:

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

```motoko title="src/PROJECT_NAME_backend/main.mo"
import Timer "mo:base/Timer";
import Nat8 "mo:base/Nat8";
import Debug "mo:base/Debug";
import Blob "mo:base/Blob";
import Nat "mo:base/Nat";

actor {
    // Store the current random number
    stable var currentRandomNumber : Nat = 0;

    let SubnetManager : actor {
      raw_rand() : async Blob;
    } = actor "aaaaa-aa";

    // Function to generate a new random number
    private func generateNewNumber() : async () {
        let randomBytes = await SubnetManager.raw_rand();
        if (randomBytes.size() > 0) {
            // Use the first byte to generate a number between 0 and 255
            let bytes : [Nat8] = Blob.toArray(randomBytes);
            currentRandomNumber := Nat8.toNat(bytes[0]);
        };
        Debug.print("Generated new random number: " # Nat.toText(currentRandomNumber));
    };

    // Public query to get current random number
    public query func getCurrentNumber() : async Nat {
        currentRandomNumber
    };

    // highlight-start
    // Initialize timer to generate new number every 5 seconds
    let timer = Timer.recurringTimer(#seconds 5, generateNewNumber);
    // highlight-end
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust title="src/PROJECT_NAME_backend/src/lib.rs"


```

</TabItem>
</AdornedTabs>


## Next step

- [x] [Learn how to deploy and manage your canister](/docs/current/developer-docs/getting-started/deploy-and-manage).
