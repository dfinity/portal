---
keywords: [beginner, getting started, tutorial, hello world, writing code, writing smart contracts, write, smart contracts, write code]
---

import TabItem from "@theme/TabItem";
import useBaseUrl from "@docusaurus/useBaseUrl";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";

# Write smart contracts

<MarkdownChipRow labels={["Beginner", "Getting started", "Tutorial"]} />

## Overview

Canisters are an enhanced type of smart contract. All canister code is compiled into a WebAssembly (Wasm) program before it is deployed on ICP, providing it with additional features and capabilities that traditional smart contracts do not have. These features include the ability to store persistent data, be managed by entities such as DAOs, and host entire applications. Each canister has the following components:

<div class="text--center">
<img src="/img/docs/inside-canister.png" alt="Canister" width="600"/>
</div>

[Learn more about each component of a canister](/docs/current/developer-docs/smart-contracts/overview/inside-canisters).

## Canister code

To write code for a canister, a canister development kit (CDK) should be used. CDKs are designed to provide build scripts that link to the ICP system API and compile the canister code into Wasm programs that are compatible with ICP. For the convenience of developers, `dfx` automatically wraps these build scripts into commands such as `dfx build`.

Currently supported CDKs include:

- [Motoko](/docs/current/motoko/main/getting-started/motoko-introduction): ICP's native programming language. By default, Motoko is installed with the IC SDK. Alternatively, you can [build it from source](https://github.com/dfinity/motoko/blob/master/Building.md).

- [Rust CDK](https://github.com/dfinity/cdk-rs): By default, the Rust CDK is included as a dependency of the IC SDK. Alternatively, you can [install it yourself](https://crates.io/crates/ic-cdk).

- [Kybra: Python CDK (Beta)](/docs/current/developer-docs/backend/python/): Learn more about how to [install and use Azle](/docs/current/developer-docs/backend/typescript/).

- [Azle: TypeScript CDK (Beta)](/docs/current/developer-docs/backend/typescript/): Learn more about how to [install and use Kybra](/docs/current/developer-docs/backend/python/).

- [Bitfinity EVM for Solidity (Beta)](/docs/current/developer-docs/backend/solidity/): Learn more about how to use the [Bitfinity EVM](https://docs.bitfinity.network/ic-agent/overview).

- [C++ CDK](https://docs.icpp.world/): Supported through the [ICPP-pro CDK](https://docs.icpp.world/installation.html).



:::info To create a canister, first you need a project.

If you downloaded your ICP Ninja project, navigate into that project folder using a command like `cd /path/to/icp/ninja/project`.

If you did not download an ICP Ninja project or if you would like to start from a new project, run:

<AdornedTabs>
<TabItem value="motoko" label="Motoko" default={true}>

```
dfx new PROJECT_NAME --type=motoko
cd PROJECT_NAME
```

</TabItem>
<TabItem value="rust" label="Rust">

```
dfx new PROJECT_NAME --type=rust
cd PROJECT_NAME
```

</TabItem>
</AdornedTabs>
:::


You should be in a directory that contains a file called `dfx.json`. This file is used to configure your project's settings. It includes the project's canister definitions, such as the canister's type, source code file, and dependencies.

```json
  "canisters": {
    "backend": {  // Canister name
      "main": "backend/main.mo",  // Canister source code
      "type": "motoko" // Canister type
    },
    "frontend": {  // Canister name
      "dependencies": ["backend"],
      "frontend": {
        "entrypoint": "frontend/index.html" // Canister source code
      },
      "source": ["frontend/dist"],
      "type": "assets"  // Canister type
    },
...
```

The `dfx.json` file will be covered more extensively in the [write smart contracts](/docs/current/developer-docs/getting-started/write-smart-contracts) page.

You will need to create each canister defined in this file using the command:

```
dfx canister create CANISTER_NAME --network ic
```

<details>
<summary>Output</summary>

```
Creating canister backend...
backend canister created on network ic with canister id: ttdiw-gqaaa-aaaak-ao5da-cai
```

</details>

This command creates an empty canister. It does not compile or install code into the canister; it simply reserves the canister's ID and sets up the canister's initial settings.



## Writing code

### Default project template

### Using randomness

### Using timers

### Using HTTPS outcalls

## Next steps



The default `Hello, world!` dapp uses `dfx`'s default template which contains two canisters, `hello_backend` and `hello_frontend`.

The `hello_frontend` canister is used to store the dapp's frontend assets. This includes files such as HTML, CSS, JavaScript, React, images, and videos.

The `hello_backend` canister is used to store the dapp's functions and core logic.

<div class="text--center">
  <img
    src={useBaseUrl("/img/docs/default-dapp-arch.png")}
    alt="Application architecture"
    width="800"
  />
</div>

:::info
It is important to note that a canister is capable of storing both the frontend assets and backend code. However, `dfx` by default uses a project template with a dedicated canister for the frontend since this allows any language to be used for the backend canister without needing to use a library for the assets storage API.
:::

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko" default>

Motoko is an actor-based language and it represents the smart contract as an actor with various methods that the users and other smart contract can call.

This hello world actor has a single function called greet. It is marked as query because it doesn't modify the state of the actor. The function accepts a name as input and returns a greetings text.

```motoko title="src/hello_backend/main.mo"
actor {
  public query func greet(name : Text) : async Text {
    return "Hello, " # name # "!";
  };
};
```

</TabItem>

<TabItem value="rust" label="Rust">

### Install Rust

You will need to install Rust in your environment with the command:

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

### Install `wasm32-unknown-unknown` target

ICP smart contracts are compiled into WebAssembly modules. To support this compilation, install the `wasm32-unknown-unknown` target:

```
rustup target add wasm32-unknown-unknown
```

This Rust smart contract has a single function called greet. It is marked as query because it doesn't modify the state of the canister.

The function accepts a name as input and returns a greetings text.

```rust title="src/hello_backend/src/lib.rs"
#[ic_cdk::query]
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}
```

</TabItem>

</AdornedTabs>








```
import Random "mo:base/Random";
import Timer "mo:base/Timer";
import Nat8 "mo:base/Nat8";
import Debug "mo:base/Debug";
import Blob "mo:base/Blob";
import Array "mo:base/Array";
import Nat "mo:base/Nat";

actor {
    // Store the current random number
    stable var currentRandomNumber : Nat = 0;

    // Function to generate a new random number
    private func generateNewNumber() : async () {
        let entropy = await Random.blob();
        let randomBytes = Blob.toArray(entropy);
        if (randomBytes.size() > 0) {
            // Use the first byte to generate a number between 0 and 255
            currentRandomNumber := Nat8.toNat(randomBytes[0]);
        };
        Debug.print("Generated new random number: " # Nat.toText(currentRandomNumber));
    };

    // Initialize timer to generate new number every 30 seconds
    let timer = Timer.recurringTimer(#seconds 30, generateNewNumber);

    // Public query to get current random number
    public query func getCurrentNumber() : async Nat {
        currentRandomNumber
    };

}
```