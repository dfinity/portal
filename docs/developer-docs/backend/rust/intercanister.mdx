---
keywords: [beginner, rust, tutorial, inter-canister, calls]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Inter-canister calls

<MarkdownChipRow labels={["Beginner", "Rust"]} />

Just like users can call canisters, canisters can also call other canisters. This tutorial provides an introduction to using these inter-canister calls in Rust.

We will show how to call the [counter canister](/docs/current/developer-docs/backend/rust/counter), which provides just four operations on a counter: getting the counter value, incrementing the counter, setting the counter to an arbitrary value, and setting the counter to an arbitrary value while returning the previous value.

## Prerequisites

We assume that you have the Internet Computer [developer tools](/docs/current/developer-docs/getting-started/install) developer tools installed. To follow along, clone the [Git repository](https://github.com/oggy-dfin/icc_rust_docs) of this tutorial. You can find the completed code in the `caller` package. Check out the Git repository of the tutorial. Then, in the tutorial directory, start a local IC instance in the background and install the counter canister.

```bash
$ dfx start --background
$ dfx deploy counter
```

## Basic example: getting and setting the counter value

For the first example, we'll build a `call_get_and_set` method on the caller canister, which just invokes the `get_and_set` method on the counter project and forwards the result. This method sets the counter to the new value, and returns the previous counter value. The finished code for the project is already available in `src/caller`. You can clear the contents of `src/caller/src/lib.rs`, and paste the following code. The explanation is in the comments.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/a8bec7765b6645146482c9f3ef146f759f996b06/src/caller/src/lib.rs#L1-L38
```

Now, deploy this code to the local IC instance. This will give you some warnings about unused imports, but we will use these later in the tutorial.

```bash
$ dfx deploy caller
```

Let's test it out. Since the method expects the principal of the counter to be passed, we can call it like this:

```bash
$ dfx canister call caller call_get_and_set
```

This will prompt you to provide a principal for the `counter` parameter of the `call_get_and_set` method. If you followed the instructions in the prerequisite section correctly and have already installed the `counter` canister, you can type `counter` and press `TAB` on your keyboard to pass the principal of the counter canister as the parameter, and then `Enter` to confirm. Also select some number to set the counter to, say `42`. Instruct `dfx` to send the message. Then, you will see an output such as:

```bash
(0 : nat, 42 : nat)
```

Here, that the counter was increased from `0` to `42`.

## IC calls are asynchronous: non-atomic set-then-get

You have already seen that the inter-canister calls use the Rust `async/await` syntax, hinting at the fact that these calls are **asynchronous**. This is a profound difference to the messaging model of some other chains (e.g., Ethereum). It enables significantly higher throughput, but can also affect correctness. To illustrate, let's look at the following example, where we first call the `set` method on the counter, and then call `get` afterwards. Add the following code to your  `src/caller/src/lib.rs`.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/8b432a1914bff877d509e91f24cff579b194f7f4/src/caller/src/lib.rs#L40-L58
```

Let's try this out. Here, we'll pass the arguments directly to `dfx` instead of using the menu, by encoding [Candid values](/docs/current/developer-docs/smart-contracts/candid/candid-concepts) manually.

```bash
$ dfx canister call caller set_then_get "record { counter: \"$(dfx canister id counter)\", new_value: 7 }"
```

You should get the expected result:

```bash
(7: nat)
```

That is, the value the we read from the counter is exactly the same as the value that we set. But as noted in the comments, this doesn't always have to hold! As IC calls are executed asynchronously, in between when the `set` and `get` calls in `call_get_and_set` execute, another canister could also call the `counter` canister and change the counter value. This of course cannot happen on your local installation since you control exactly which calls are made, but it can happen as soon as you install the code on the IC mainnet. This behavior enables much higher concurrent throughput between different canisters, since the counter canister isn't blocked from processing other requests while the caller canister is doing its processing. But it also has correctness and security implications. Read the documentation on [inter-canister calls and async code](/docs/current/developer-docs/smart-contracts/advanced-features/async-code), [properties of call execution](/docs/current/developer-docs/security/security-best-practices/inter-canister-calls) and [security best practices](docs/current/developer-docs/security/security-best-practices/inter-canister-calls) to understand potential security implications for your application when using inter-canister calls.

## Bounded-wait and unbounded-wait calls, and error handling: set vs increment

In our first examples we ignored error handling, but a robust application should handle errors to the extent possible. While concrete error handling is application-specific, we will now explain the different ways in which calls can fail. Furthermore, so far we always used unbounded-wait calls. We will now also see when to use bounded-wait calls, and briefly explore the trade-offs between them.

*Bounded-wait calls* do not wait forever for the response to arrive. These calls have two significant advantages: (1) they ensure that your canister won't stall (in particular, become unable to stop and upgrade) if it calls into canisters you don't control, and (2) they scale much better. On the flip side, they have more complicated error handling (where you must handle the case of the call timing out, much like a broken network connection), and are not suitable for all types of calls.

Let's see how one can do error handling in the case of the `set` method. We will take advantage of the fact that the `set` method is *idempotent*. That is, executing it twice has the same effect as executing it just once. Making public endpoints idempotent is a [best practice](/docs/current/developer-docs/smart-contracts/best-practices/idempotency). It enables better error recovery for ingress calls (i.e., outside users and applications interacting with your application over HTTP) to your canister, but also enables other canisters to handle call errors when calling your canister using bounded-wait calls.

Edit `src/caller/src/lib.rs` to add the following method:

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/master/src/caller/src/lib.rs#L150-L236
```

Now, let's try it out. Redeploy the canister:

```bash
$ dfx deploy caller
```

and then call the new endpoint with the value 42.

```bash
$ dfx canister call caller stubborn_set '(42)'
```

Now let's can check whether the counter canister actually set its value correctly by calling it directly.

```bash
$ dfx canister call counter get
(42 : nat)
```

Bounded-wait calls are often not suitable for calling non-idempotent endpoints. For example, the `increment` endpoint of the counter canister is obviously not idempotent, as executing it twice doesn't have the same effect as executing it once. This makes handling the `SysUnknown` case more difficult. One possible way of handling it involves invoking `get` on the counter to first read the old value, then calling `increment`, and, in case of a `SysUnknown` error, calling `get` again to check whether the counter value was incremented, and only retrying if it wasn't. As discussed earlier, since the counter value may be changed by an external party in between our calls, the error handling would also have to take that into account and decide what an appropriate course of action is. These problems can be avoided by using unbounded-wait calls, since these can never result in a `SysUnknown` error. However, that does lose the advantages of bounded-wait calls, and you may still have to handle other error cases with a similar effect (such as `CanisterError`).

## Attaching cycles: canister signatures

A Canister can attach [cycles](/docs/current/developer-docs/getting-started/tokens-and-cycles) (Internet Computer "gas") to any call that they make, transferring cycles from the caller's to the callee's cycle balance. The callee must explicitly [accept](https://docs.rs/ic-cdk/latest/ic_cdk/api/call/fn.msg_cycles_accept128.html) such cycles; non-accepted cycles are refunded to the caller.

Cycle transfers are generally either used to pay for the callee's costs of processing the call, or to move and store cycles around as assets. An example where they are used to pay for call processing costs is the IC [on-chain signature feature](/docs/current/developer-docs/smart-contracts/signatures/t-ecdsa), which allows a canister to hold a cryptographic key and sign messages with it. An example of cycles being used as assets is the [cycles ledger](/docs/current/developer-docs/defi/cycles/cycles-ledger/).

Below, we use the on-chain signature example to show how to attach cycles to a call.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/b75855e988fa0e18ec6ca100fcdae576cdf0e848/src/caller/src/lib.rs#L137-L170
```

Cycles can be attached to both bounded and unbounded wait messages. For unbounded wait messages, cycles that are not consumed by the callee are guaranteed to be refunded to the caller. For bounded wait calls, refunds do not happen when the call returns a `SysUnknown` error. However, this is usually acceptable for API calls that charge for cycles, since the amount charged is usually low (10 billion cycles for signatures with the test key). For transferring larger amounts of cycles, switch to using unbounded wait calls. See the section on [inter-canister calls](/docs/current/developer-docs/smart-contracts/advanced-features/async-code) for more details.


## Further reading

To understand more details about how inter-canister calls execute, how different call types and  consult the documentation on [inter-canister calls and async code](/docs/current/developer-docs/smart-contracts/advanced-features/async-code).
As noted in our examples, an `update` method can always call any method of any other canister. In cases where you only need to call query methods on other canisters, and if you are sure that these canisters are on the same subnet as your canister, you can also use [composite query calls](/docs/current/developer-docs/smart-contracts/call/overview) methods instead of update methods.

For a real-life example of how to handle errors when calling canisters, see the [ICRC-1 examples](/docs/current/developer-docs/defi/tokens/ledger/usage/icrc1_ledger_usage#interacting-with-an-icrc-1-ledger-from-another-canister-inter-canister-calls-via-ic-cdk)

<!--

### Basic ICP ledger transfer: unbounded wait calls

The simplest way to interact with the ICP ledger is to use calls where the caller is willing to wait for the response for an unbounded amount of time. These calls can still fail before reaching the ledger, or even while the ledger is processing the call. but the ledger's response is guaranteed do be delivered to the caller, which is why we also refer to these calls as *guaranteed response*  calls.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/7c3a0195c7a78eff8813d80d18b8575535a05c3b/src/icc_rust_docs_backend/src/lib.rs#L14-L81
```

The guaranteed response delivery property ensures that the only causes of `StateUnknown` error are due to canister behavior (mismatched expectations on the return types, or the callee panicking). However, there is also a downside to unbounded wait calls: since safely upgrading a canister can only be done when the canister has no pending calls, and since unbounded wait calls provide no bound on when the call will return, the caller may be prevented from upgrading safely. This can in particular be problematic when calling untrusted canisters, such as an arbitrary ledger.

We will next show how to use *bounded wait* calls instead in such cases. These calls don't guarantee that the response will be delivered, which is why we also refer to them as *best-effort response calls*, but in return don't block the caller from upgrading, and they also tolerate high system load better than unbounded wait calls. See the section on [inter-canister calls](/docs/current/developer-docs/smart-contracts/advanced-features/async-code) for more information on best-effort vs. guaranteed response calls.

### Transfers on arbitrary ICRC-1 ledgers: bounded wait calls

ICRC-1 is a standard defining an API for token ledgers on the Internet Computer. Any canister can implement this API and act as a ledger. A dApp (for example, a decentralized exchange or a wallet application that serves multiple users) may want to allow users to register arbitrary such ledgers and interact with them, without knowing if they faithfully implement the standard. In this example we show how we could modify our wallet to transfer tokens on an arbitrary ICRC-1 ledger instead of just the ICP ledger. To ensure that our canister can always be upgraded, we will use bounded wait calls.

Ledgers generally charge fees for transfers. While this fee is fixed for the ICP ledger, it may vary for other ledgers. Thus, we start with an example of how to determine the required fee.

#### Learning the transfer fee

Querying the transfer fee does not change the ledger state. Thus, it's simple to retry in case that it fails, and the code below implements basic retries.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/34f59ddae9fcc70173fc21927a4279757f93c51a/src/icc_rust_docs_backend/src/lib.rs#L83-L134
```

As noted in the example, the code after the first call executes in a different callback. See the sections on [inter-canister calls and async code](/docs/current/developer-docs/smart-contracts/advanced-features/async-code), [properties of call execution](/docs/current/developer-docs/security/security-best-practices/inter-canister-calls) and [security best practices](docs/current/developer-docs/security/security-best-practices/inter-canister-calls) to understand potential security implications for your application when using inter-canister calls.

#### Transferring tokens

When transferring tokens (or performing other updates) using bounded wait messages, we need to handle the unknown state case. For ICRC-1 transfers, we can make use of the built-in deduplication feature of ICRC-1 ledgers and retry the call.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/34f59ddae9fcc70173fc21927a4279757f93c51a/src/icc_rust_docs_backend/src/lib.rs#L136-L211
```

### Exchange rate canister: attaching cycles

For our final example, we will use the [exchange rate canister](/docs/current/developer-docs/defi/exchange-rate-canister/) (XRC) to determine the exchange rate between assets, including tokens, but also currencies. The XRC uses [HTTP outcalls](/docs/current/developer-docs/smart-contracts/advanced-features/https-outcalls/https-outcalls-overview) to determine the exchange rate. Similar to ledgers charging transfer fees, the XRC charges a fee to the caller to determine the exchange rate. However, since the XRC doesn't have a token of its own, the XRC fee is paid in cycles rather than a token. The user has to attach cycles to such a call. Cycles can be attached to both bounded and unbounded wait messages. For unbounded wait messages, cycles that are not consumed by the callee are guaranteed to be refunded to the caller. For bounded wait calls, refunds do not happen when the call returns a `SysUnknown` error. However, this is usually acceptable for API calls that charge for cycles, since the amount charged is usually low (1 billion cycles for the XRC). For transferring larger amounts of cycles, switch to using unbounded wait calls. See the section on [inter-canister calls](/docs/current/developer-docs/smart-contracts/advanced-features/async-code) for more details.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/34f59ddae9fcc70173fc21927a4279757f93c51a/src/icc_rust_docs_backend/src/lib.rs#L213-L247
```

### Dependencies and imports

We start by listing the dependencies used in this example as specified in `Cargo.toml`.

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/34f59ddae9fcc70173fc21927a4279757f93c51a/src/icc_rust_docs_backend/Cargo.toml#L11-L16
```

Next, here are the imports used:

```rust reference
https://github.com/oggy-dfin/icc_rust_docs/blob/34f59ddae9fcc70173fc21927a4279757f93c51a/src/icc_rust_docs_backend/src/lib.rs#L1-L8
```


-->
