# Architecture 

## Overview 

One of the most important decisions when designing a dapp is determining the project's architecture. Three commonly used project architectures include:

- **Single canister projects**: Consists of a single canister that contains the entire project's functionality. This may be a single service, a frontend webpage, or both within a single canister. Benefits of single canister projects include:

    - Simplified management and maintenance.

    - A lower cost than some multi-canister projects (though this depends on several factors). 

    - Can be a good starting place for new developers as they learn about developing on ICP. 

    Example use cases:

    - Hosting a webpage or website.

    - Hosting a simple service, such as a calculator.

    - Hosting a simple game.

    - Hosting a simple dapp with frontend and backend code together in a single canister. 

    An example single-canister project can be found in the [DFINITY examples repo](https://github.com/dfinity/examples/tree/master/motoko/calc).

- **Multi-canister projects**: Contains multiple canisters that divide the project's functions into several canisters with specific purposes. Multi-canister projects are the default project architecture generated by the `dfx new` command. The most common multi-canister architecture consists of a canister for the project's frontend assets and a canister for the dapp's backend code. Multi-canister projects are also commonly used when it makes sense to place different reusable services into separate canisters. Benefits of multi-canister projects include:

    - Better scalability than single canister projects.
    
    - Upgrading individual services may be easier. 

    - Canisters providing a reusable service can be configured as ['pullable'](/docs/current/developer-docs/setup/pulling-canister-dependencies) and re-used in other projects through [`dfx deps`](/docs/current/developer-tools/cli-tools/cli-reference/dfx-deps). 

    Example use cases:

    - A fullstack dapp with a frontend application and several backend functionality canisters.

    - A decentralized exchange or token swap dapp.

    - A social media dapp. 

    - A video streaming dapp.

    - A photo upload and storage dapp.

    - A decentralized game.

    - An NFT collection and a frontend application to mint, sell, or buy NFTs. 

    An example multi-canister project can be found in the [DFINITY examples repo](https://github.com/dfinity/examples/tree/master/motoko/ic-pos).

## Architectures compared 

| Feature | Single | Multi | 
|---------|--------|-------|
| Management | Single canister to manage. | Multiple canisters to manage, but each canister has a specific function. |
| Scalability | Hard to scale for large projects. | Better scalability than single projects. | 
| Reusability | Typically can't be reused. | Service-specific canisters can be reused in other projects. | 
| Cost | Typically relatively low, but will depend on total number of resources used. | Larger cost than single canister, but will vary drastically based on total number of canisters and resources used. | 

## Architecture best practices

### Recommendation: Serve reusable services in their own canisters 

Serving individual services in their own canisters makes it easy to call, manage, and reuse those services. For example, a social media application may have functionality for creating user profiles, sending messages, or uploading photos. If these three services are separated into three separate canisters, managing, upgrading, and using those services is simplified. Additionally, these canisters can each be published as ['pullable'](/docs/current/developer-docs/setup/pulling-canister-dependencies) canisters, then reused in another dapps, preventing developers from having to redeploy the same code in different projects.

### Recommendation: End-users should interact with a dapp from a frontend application

For the best user experience, end-users should interact with dapps from a frontend application. Using a frontend application provides users with a familiar interface to interact with dapps, while the alternative (calling the canister via the CLI or Candid) can be difficult for non-technical users and lead to a poor user experience. 

### Recommendation: Use multiple keys to further secure assets

For dapps that provide custodial functions, such as holding or trading assets, you can secure these assets further by utilizing multiple [TECDSA keys](/docs/current/developer-docs/integrations/t-ecdsa/index) hosted on different subnets. By using two keys, multiple subnets would have to conspire and collaborate to compromise assets.
