---
keywords: [beginner, tutorial, canister, introduction]
---

import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";
import { GlossaryTooltip } from "/src/components/Tooltip/GlossaryTooltip";


# What are canisters?

<MarkdownChipRow labels={["Beginner", "Concept"]} />

The smart contracts running on ICP are a powerful evolution of traditional smart contracts. ICP smart contracts are called **canisters** and are computational units that combine both code and data. Canisters can contain any arbitrary code or data, from serving web pages to creating a secure messaging app, or implementing a decentralized token exchange.

<div class="text--center">
<img src="/img/docs/canister.png" alt="Canister" width="400"/>
</div>

Canisters have special properties that allow developers to build scalable Web3 services. To better understand these properties, one has to consider canisters from different perspectives to form a complete picture of their capabilities.

An Ethereum developer might think of canisters as smart contracts, whereas someone with an academic background might make associations with actors and the [actor model](https://en.wikipedia.org/wiki/Actor_model).

A systems engineer will likely consider operating systems processes, whereas a virtual machine expert might think about WebAssembly module instances.

While these associations are partial, they are correct. Together they form a comprehensive picture of what a canister is. Let’s look at them one by one.

[Introducing canisters — An evolution of smart contracts](https://www.youtube.com/watch?v=LKpGuBOXxtQ).

## Canisters as smart contracts

Canisters are much like a smart contract in that their execution is governed by a secure protocol; in this case, the ICP protocol. Canisters running on ICP are tamper-proof, since their state can only be modified through messages that are executed onchain. A canister’s state can be audited and cryptographically verified using ICP’s chain-key cryptography.
For a brief comparison between canisters and Ethereum smart contracts, refer to the table [Quick comparison with Ethereum](/docs/developer-docs/getting-started/network-overview.mdx#quick-comparison-with-ethereum).

## Canisters as actors

Canisters are much like actors when thinking about them abstractly. Following the [actor model of concurrent computation](https://en.wikipedia.org/wiki/Actor_model), canisters respond to messages they receive by performing one or more of the following actions:
- Modifying their private state.
- Sending messages to other canisters (actors).
- Creating more canisters (actors).

Although canisters have a single thread of execution, multiple can be executed concurrently. This is a key feature of ICP that overcomes the scaling challenges of other smart contract platforms.

## Canisters as OS processes

Canisters behave much like operating system processes. Similar to how an operating system schedules processes, ICP schedules the execution of canisters. [Learn more about the execution of canisters](https://internetcomputer.org/how-it-works).

An operating system maintains state on behalf of processes, like their open file descriptors, similar to how ICP maintains state on behalf of canisters, such as their cycle balance or its outstanding calls to other canisters.

Operating system processes cannot directly modify their table of file descriptors or manipulate peripheral devices, similar to how canisters cannot directly modify their <GlossaryTooltip>cycles</GlossaryTooltip> balance.

ICP provides APIs to canisters that allow them to make payments to other canisters, send them messages, and create and manage other canisters.

## Canisters as WebAssembly module instances

Canisters are implemented as WebAssembly modules. This allows for maximum interoperability, as developers can write canisters in a variety of languages that target WebAssembly.

A canister is a WebAssembly module instance complete with its own state and execution stack. Canisters’ memory uses [orthogonal persistence](https://medium.com/dfinity/ic-internals-orthogonal-persistence-9e0c094aac1a), which makes storing canister data transparent for users. The data of the canister’s WebAssembly module is persisted automatically by the system and is present the next time the canister is scheduled for execution. The WebAssembly module itself is stored along with other bits of the canister’s state.
