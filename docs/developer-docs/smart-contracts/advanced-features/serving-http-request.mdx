---
keywords: [advanced, tutorial, serving http, http requests]
---

import TabItem from "@theme/TabItem";
import { AdornedTabs } from "/src/components/Tabs/AdornedTabs";
import { AdornedTab } from "/src/components/Tabs/AdornedTab";
import { BetaChip } from "/src/components/Chip/BetaChip";
import { MarkdownChipRow } from "/src/components/Chip/MarkdownChipRow";

# Serving an HTTP request

<MarkdownChipRow labels={["Advanced", "Tutorial"]} />

## Overview

Canisters can serve or handle an incoming HTTP request using the [HTTP Gateway Protocol](/docs/current/references/http-gateway-protocol-spec).

This allows developers to host web applications and APIs from a canister.

## How it works

An HTTP request from a client gets intercepted by the HTTP Gateway Protocol, which identifies the target canister and encodes the request in Candid. This encoded request is then sent to the canister for processing. Once processed, the canister replies with an HTTP response. Finally, the HTTP Gateway Protocol decodes the response using Candid and sends it back to the client, completing the communication loop.

For detailed information on how it works, please refer to the [HTTP Gateway Protocol specification](/docs/current/references/http-gateway-protocol-spec).

## How to make a request

The following example returns 'Hello, World!' in the body at the `/hello` endpoint.

<AdornedTabs groupId="language">
<TabItem value="motoko" label="Motoko">

```motoko
import Buffer "mo:base/Buffer";

type HeaderField = (Text, Text);

type HttpResponse = {
    status_code: Nat16;
    headers: [HeaderField];
    body: Blob;
};

type HttpRequest = {
    method: Text;
    url: Text;
    headers: [HeaderField];
    body: Blob;
  };

public query func http_request(req: HttpRequest): async (HttpResponse) {
    let path = removeQuery(req.url);
    if(path == "/hello") {
        return {
            status_code = 200,
            headers = [],
            body = Buffer.from('Hello, World!'),
        };
    };
        return {
            body = Text.encodeUtf8("404 Not found :");
            headers = [];
            status_code = 404;
    };
};
```

</TabItem>

<TabItem value="rust" label="Rust">

```rust
type HeaderField = (String, String);

struct HttpResponse {
    status_code: u16,
    headers: Vec<HeaderField>,
    body: Cow<'static, Bytes>,
}

struct HttpRequest {
    method: String,
    url: String,
    headers: Vec<(String, String)>,
    body: ByteBuf,
}

#[query]
fn http_request(req: HttpRequest) -> HttpResponse {
    let path = req.url.path();
    if path == "/hello" {
        HttpResponse {
            status_code: 200,
            headers: Vec::new(),
            body: b"hello, world!".to_vec(),
            streaming_strategy: None,
            upgrade: None,
        }
    } else {
        HttpResponse {
            status_code: 404,
            headers: Vec::new(),
            body: b"404 Not found :".to_vec(),
            streaming_strategy: None,
            upgrade: None,
        }
    }
}
```

</TabItem>

<AdornedTab value={"typescript"} label="TypeScript" endAdornment={<BetaChip />}>

```typescript
import { IDL, query } from 'azle';

type HeaderField = [string, string];
const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);

type HttpResponse = {
    status_code: number;
    headers: HeaderField[];
    body: Uint8Array;
};
const HttpResponse = IDL.Record({
    status_code: IDL.Nat16,
    headers: IDL.Vec(HeaderField),
    body: IDL.Vec(IDL.Nat8)
});

type HttpRequest = {
    method: string;
    url: string;
    headers: HeaderField[];
    body: Uint8Array;
};
const HttpRequest = IDL.Record({
    method: IDL.Text,
    url: IDL.Text,
    headers: IDL.Vec(HeaderField),
    body: IDL.Vec(IDL.Nat8)
});

export default class {
    @query([HttpRequest], HttpResponse)
    getThing(req: HttpRequest): HttpResponse {
        const path = new URL(req.url).pathname;
        if (path === '/hello') {
            return {
                status_code: 200,
                headers: [],
                body: Buffer.from('hello, world!')
            };
        }
        return {
            body: new TextEncoder().encode('404 Not found :'),
            headers: [],
            status_code: 404
        };
    }
}
```

</AdornedTab>

<AdornedTab value={"python"} label="Python" endAdornment={<BetaChip />}>

```python
from kybra import blob, Func, nat16, Opt, query, Query, Record, Tuple, Variant, Vec


class HttpRequest(Record):
    method: str
    url: str
    headers: Vec["Header"]
    body: blob


class HttpResponse(Record):
    status_code: nat16
    headers: Vec["Header"]
    body: blob
    streaming_strategy: Opt["StreamingStrategy"]
    upgrade: Opt[bool]


Header = Tuple[str, str]


class StreamingStrategy(Variant):
    Callback: "CallbackStrategy"


class CallbackStrategy(Record):
    callback: "Callback"
    token: "Token"


Callback = Func(Query[["Token"], "StreamingCallbackHttpResponse"])


class StreamingCallbackHttpResponse(Record):
    body: blob
    token: Opt["Token"]


class Token(Record):
    arbitrary_data: str


@query
def http_request(req: HttpRequest) -> HttpResponse:
    return {
        "status_code": 200,
        "headers": [],
        "body": bytes(),
        "streaming_strategy": None,
        "upgrade": False,
    }
```

:::caution

Kybra canisters must be deployed from a Python virtual environment. [Learn more in the Kybra docs](/docs/current/developer-docs/backend/python/).

:::

To learn more about serving an HTTP request in Python, refer to [the Kybra book reference on incoming HTTP requests](https://demergent-labs.github.io/kybra/http.html).

</AdornedTab>
</AdornedTabs>

## Additional examples

The [HTTP counter project](../../../references/samples/motoko/http_counter) is an example in Motoko of a 'counter' application that uses the `http_request` method to read the current counter value or access some pre-stored data and the `http_request_update` method to increment the counter and retrieve the updated value.
